/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.51 from the
 * contents of Slurm.xs. Do not edit this file, edit Slurm.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Slurm.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#define NEED_newRV_noinc_GLOBAL
#include "ppport.h"

#include <slurm/slurm.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#include "slurm-perl.h"

/* Custom typemap that free's memory after copying to perl stack. */
typedef char char_xfree;
typedef char char_free;

struct slurm {
};
typedef struct slurm * slurm_t;

/*
 * default slurm object, for backward compatibility with "Slurm->method()".
 */
static struct slurm default_slurm_object;

static slurm_t
new_slurm(void)
{
	int size = sizeof(struct slurm);
	if (size == 0) {
		/* Avoid returning NULL, which causes the perl APIs to fail */
		size = 1;
	}
	return xmalloc(size);
}

static void
free_slurm(slurm_t self)
{
	xfree(self);
}



/********************************************************************/

#line 58 "Slurm.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 202 "Slurm.c"

XS_EUPXS(XS_Slurm_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_new)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	slurm_t	RETVAL;
#line 65 "Slurm.xs"
		RETVAL = new_slurm();
		if (RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 217 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv( RETVALSV, "Slurm", (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_DESTROY() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 75 "Slurm.xs"
		if (self != &default_slurm_object) {
			free_slurm(self);
		}
#line 251 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_get_errno); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_errno)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_errno() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 86 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = errno;
#line 284 "Slurm.c"
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_strerror); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_strerror)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, errnum=0");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	int	errnum;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_strerror() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    errnum = 0;
	else {
	    errnum = (int)SvIV(ST(1))
;
	}
#line 98 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (errnum == 0)
			errnum = errno;
		RETVAL = slurm_strerror(errnum);
#line 329 "Slurm.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_preempt_mode_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_preempt_mode_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, preempt_mode");
    {
	const char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint16_t	preempt_mode = (unsigned short)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_preempt_mode_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 119 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_preempt_mode_string(preempt_mode);
#line 367 "Slurm.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_preempt_mode_num); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_preempt_mode_num)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, preempt_mode");
    {
	uint16_t	RETVAL;
	dXSTARG;
	slurm_t	self;
	char *	preempt_mode = (char *)SvPV_nolen(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_preempt_mode_num() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 133 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 404 "Slurm.c"

	RETVAL = slurm_preempt_mode_num(preempt_mode);
	XSprePUSH;
	PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_reason_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_reason_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, inx");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	inx = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_reason_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 142 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = (char *)slurm_job_state_reason_string(inx);
#line 443 "Slurm.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_state_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_state_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, inx");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	inx = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_state_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 154 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_job_state_string(inx);
#line 481 "Slurm.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_state_string_compact); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_state_string_compact)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, inx");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	inx = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_state_string_compact() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 166 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_job_state_string_compact(inx);
#line 519 "Slurm.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_state_num); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_state_num)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, state_name");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	char *	state_name = (char *)SvPV_nolen(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_state_num() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 180 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 556 "Slurm.c"

	RETVAL = slurm_job_state_num(state_name);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_reservation_flags_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_reservation_flags_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, resv_hv");
    {
	char_xfree *	RETVAL;
	slurm_t	self;
	HV *	resv_hv;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_reservation_flags_string() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    resv_hv = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::reservation_flags_string",
				"resv_hv");
		}
	} STMT_END
;
#line 189 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		reserve_info_t resv;
		if (hv_to_reserve_info(resv_hv, &resv) < 0) {
			XSRETURN_UNDEF;
		}

		RETVAL = slurm_reservation_flags_string(&resv);
#line 612 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setpv ((SV*)RETVALSV, RETVAL);
	    xfree (RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_node_state_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_node_state_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, inx");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	inx = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_node_state_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 206 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_node_state_string(inx);
#line 654 "Slurm.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_node_state_string_compact); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_node_state_string_compact)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, inx");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	inx = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_node_state_string_compact() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 218 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_node_state_string_compact(inx);
#line 692 "Slurm.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_private_data_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_private_data_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, private_data");
    {
#line 230 "Slurm.xs"
		char tmp_str[128];
#line 710 "Slurm.c"
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint16_t	private_data = (unsigned short)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_private_data_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 232 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		slurm_private_data_string(private_data, tmp_str, sizeof(tmp_str));
		RETVAL = tmp_str;
#line 734 "Slurm.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_accounting_enforce_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_accounting_enforce_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, enforce");
    {
#line 245 "Slurm.xs"
		char tmp_str[128];
#line 752 "Slurm.c"
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint16_t	enforce = (unsigned short)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_accounting_enforce_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 247 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		slurm_accounting_enforce_string(enforce, tmp_str, sizeof(tmp_str));
		RETVAL = tmp_str;
#line 776 "Slurm.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_allocate_resources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_allocate_resources)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_desc");
    {
#line 266 "Slurm.xs"
		job_desc_msg_t jd_msg;
		resource_allocation_response_msg_t* resp_msg = NULL;
		int rc;
#line 796 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	HV *	job_desc;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_allocate_resources() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    job_desc = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::allocate_resources",
				"job_desc");
		}
	} STMT_END
;
#line 270 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_job_desc_msg(job_desc, &jd_msg) < 0) {
			XSRETURN_UNDEF;
		}
		rc = slurm_allocate_resources(&jd_msg, &resp_msg);
		free_job_desc_msg_memory(&jd_msg);
		if (resp_msg == NULL) {
			XSRETURN_UNDEF;
		}
		if(rc != SLURM_SUCCESS) {
			slurm_free_resource_allocation_response_msg(resp_msg);
			XSRETURN_UNDEF;
		}
		RETVAL = newHV();
		sv_2mortal((SV*)RETVAL);
		rc = resource_allocation_response_msg_to_hv(resp_msg, RETVAL);
		slurm_free_resource_allocation_response_msg(resp_msg);
		if (rc < 0) {
			XSRETURN_UNDEF;
		}
#line 849 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_allocate_resources_blocking); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_allocate_resources_blocking)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "self, user_req, timeout=0, pending_callback=NULL");
    {
#line 300 "Slurm.xs"
		job_desc_msg_t jd_msg;
		resource_allocation_response_msg_t *resp_msg = NULL;
#line 871 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	HV *	user_req;
	time_t	timeout;
	SV *	pending_callback;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_allocate_resources_blocking() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    user_req = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::allocate_resources_blocking",
				"user_req");
		}
	} STMT_END
;

	if (items < 3)
	    timeout = 0;
	else {
	    timeout = (time_t)SvNV(ST(2))
;
	}

	if (items < 4)
	    pending_callback = NULL;
	else {
	    pending_callback = ST(3)
;
	}
#line 303 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_job_desc_msg(user_req, &jd_msg) < 0) {
			XSRETURN_UNDEF;
		}
		set_sarb_cb(pending_callback);
		resp_msg = slurm_allocate_resources_blocking(&jd_msg, timeout,
				pending_callback == NULL ? NULL : sarb_cb);
		free_job_desc_msg_memory(&jd_msg);
		if (resp_msg != NULL) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			resource_allocation_response_msg_to_hv(resp_msg, RETVAL);
			slurm_free_resource_allocation_response_msg(resp_msg);
		}
		else {
			XSRETURN_UNDEF;
		}
#line 937 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_allocation_lookup); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_allocation_lookup)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
#line 331 "Slurm.xs"
		resource_allocation_response_msg_t *resp_msg = NULL;
		int rc;
#line 959 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_allocation_lookup() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 334 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_allocation_lookup(job_id, &resp_msg);
		if(rc != SLURM_SUCCESS) {
			slurm_free_resource_allocation_response_msg(resp_msg);
			XSRETURN_UNDEF;
		}
		RETVAL = newHV();
		sv_2mortal((SV*)RETVAL);
		rc = resource_allocation_response_msg_to_hv(resp_msg, RETVAL);
		slurm_free_resource_allocation_response_msg(resp_msg);
		if (rc < 0) {
			XSRETURN_UNDEF;
		}
#line 992 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_read_hostfile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_read_hostfile)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, filename, n");
    {
	char_free *	RETVAL;
	slurm_t	self;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	int	n = (int)SvIV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_read_hostfile() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 357 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_read_hostfile(filename, n);
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 1037 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setpv ((SV*)RETVALSV, RETVAL);
	    free (RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_allocation_msg_thr_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_allocation_msg_thr_create)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, port, callbacks");
    {
	allocation_msg_thread_t *	RETVAL;
	slurm_t	self;
	uint16_t	port;
	HV *	callbacks;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_allocation_msg_thr_create() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    callbacks = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::allocation_msg_thr_create",
				"callbacks");
		}
	} STMT_END
;
#line 372 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		set_sacb(callbacks);
#line 1092 "Slurm.c"

	RETVAL = slurm_allocation_msg_thr_create(&port, &sacb);
	sv_setuv(ST(1), (UV)port);
	SvSETMAGIC(ST(1));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv( RETVALSV, "Slurm::allocation_msg_thread_t", (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_allocation_msg_thr_destroy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_allocation_msg_thr_destroy)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, msg_thr");
    {
	slurm_t	self;
	allocation_msg_thread_t *	msg_thr;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_allocation_msg_thr_destroy() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::allocation_msg_thread_t")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		msg_thr = INT2PTR(allocation_msg_thread_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::allocation_msg_thr_destroy",
			"msg_thr", "Slurm::allocation_msg_thread_t");
	}
;
#line 384 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */

#line 1144 "Slurm.c"

	slurm_allocation_msg_thr_destroy(msg_thr);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_submit_batch_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_submit_batch_job)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_desc");
    {
#line 396 "Slurm.xs"
		job_desc_msg_t jd_msg;
		submit_response_msg_t *resp_msg = NULL;
		int rc;
#line 1163 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	HV *	job_desc;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_submit_batch_job() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    job_desc = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::submit_batch_job",
				"job_desc");
		}
	} STMT_END
;
#line 400 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_job_desc_msg(job_desc, &jd_msg) < 0) {
			XSRETURN_UNDEF;
		}
		rc = slurm_submit_batch_job(&jd_msg, &resp_msg);
		free_job_desc_msg_memory(&jd_msg);
		if(rc != SLURM_SUCCESS) {
			slurm_free_submit_response_response_msg(resp_msg);
			XSRETURN_UNDEF;
		}
		RETVAL = newHV();
		sv_2mortal((SV*)RETVAL);
		rc = submit_response_msg_to_hv(resp_msg, RETVAL);
		slurm_free_submit_response_response_msg(resp_msg);
		if (rc < 0) {
			XSRETURN_UNDEF;
		}
#line 1213 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_will_run); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_will_run)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_desc");
    {
#line 427 "Slurm.xs"
		job_desc_msg_t jd_msg;
#line 1234 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	job_desc;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_will_run() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    job_desc = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::job_will_run",
				"job_desc");
		}
	} STMT_END
;
#line 429 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_job_desc_msg(job_desc, &jd_msg) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_job_will_run(&jd_msg);
		free_job_desc_msg_memory(&jd_msg);
#line 1274 "Slurm.c"
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_sbcast_lookup); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_sbcast_lookup)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, step_id_in");
    {
#line 445 "Slurm.xs"
		job_sbcast_cred_msg_t *info;
		int rc;
		slurm_selected_step_t selected_step;
#line 1293 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id_in = (unsigned long)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_sbcast_lookup() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 449 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		selected_step.het_job_offset = NO_VAL;
		selected_step.array_task_id = NO_VAL;
		selected_step.step_id.job_id = job_id;
		selected_step.step_id.step_id = step_id_in;
		selected_step.step_id.step_het_comp = NO_VAL;
		rc = slurm_sbcast_lookup(&selected_step, &info);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_sbcast_cred_msg_to_hv(info, RETVAL);
			slurm_free_sbcast_cred_msg(info);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 1333 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_kill_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_kill_job)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, job_id, signal, batch_flag=0");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint16_t	signal = (unsigned short)SvUV(ST(2))
;
	uint16_t	batch_flag;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_kill_job() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 4)
	    batch_flag = 0;
	else {
	    batch_flag = (unsigned short)SvUV(ST(3))
;
	}
#line 481 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1383 "Slurm.c"

	RETVAL = slurm_kill_job(job_id, signal, batch_flag);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_kill_job_step); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_kill_job_step)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "self, job_id, step_id, signal, flags");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	uint16_t	signal = (unsigned short)SvUV(ST(3))
;
	uint16_t	flags = (unsigned short)SvUV(ST(4))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_kill_job_step() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 491 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1427 "Slurm.c"

	RETVAL = slurm_kill_job_step(job_id, step_id, signal, flags);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_signal_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_signal_job)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, signal");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint16_t	signal = (unsigned short)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_signal_job() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 502 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1467 "Slurm.c"

	RETVAL = slurm_signal_job(job_id, signal);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_signal_job_step); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_signal_job_step)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "self, job_id, step_id, signal");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	uint16_t	signal = (unsigned short)SvUV(ST(3))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_signal_job_step() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 513 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1509 "Slurm.c"

	RETVAL = slurm_signal_job_step(job_id, step_id, signal);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_complete_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_complete_job)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, job_id, job_rc=0");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	job_rc;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_complete_job() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 3)
	    job_rc = 0;
	else {
	    job_rc = (unsigned long)SvUV(ST(2))
;
	}
#line 528 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1555 "Slurm.c"

	RETVAL = slurm_complete_job(job_id, job_rc);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_terminate_job_step); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_terminate_job_step)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, step_id");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_terminate_job_step() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 539 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1595 "Slurm.c"

	RETVAL = slurm_terminate_job_step(job_id, step_id);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_api_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_api_version)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
#line 558 "Slurm.xs"
		long version;
#line 1614 "Slurm.c"
	slurm_t	self;
	int	major;
	int	minor;
	int	micro;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_api_version() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 560 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		version = slurm_api_version();
		major = SLURM_VERSION_MAJOR(version);
		minor = SLURM_VERSION_MINOR(version);
		micro = SLURM_VERSION_MICRO(version);
#line 1639 "Slurm.c"
	XSprePUSH;	EXTEND(SP,3);
	PUSHs(sv_newmortal());
	sv_setiv(ST(0), (IV)major);
	PUSHs(sv_newmortal());
	sv_setiv(ST(1), (IV)minor);
	PUSHs(sv_newmortal());
	sv_setiv(ST(2), (IV)micro);
    }
    XSRETURN(3);
}


XS_EUPXS(XS_Slurm_load_ctl_conf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_ctl_conf)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, update_time=0");
    {
#line 573 "Slurm.xs"
		slurm_conf_t *ctl_conf;
		int rc;
#line 1662 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_ctl_conf() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}
#line 576 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_ctl_conf(update_time, &ctl_conf);
		if(rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = slurm_ctl_conf_to_hv(ctl_conf, RETVAL);
			slurm_free_ctl_conf(ctl_conf);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 1701 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_ctl_conf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_ctl_conf)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, out, conf");
    {
#line 599 "Slurm.xs"
		slurm_conf_t cc;
#line 1722 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	conf;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_ctl_conf() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    conf = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::print_ctl_conf",
				"conf");
		}
	} STMT_END
;
#line 601 "Slurm.xs"
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if (hv_to_slurm_ctl_conf(conf, &cc) < 0) {
			XSRETURN_UNDEF;
		}
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1763 "Slurm.c"

	slurm_print_ctl_conf(out, &cc);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_ctl_conf_2_key_pairs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_ctl_conf_2_key_pairs)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, conf");
    {
#line 622 "Slurm.xs"
		slurm_conf_t cc;
#line 1780 "Slurm.c"
	list_t *	RETVAL;
	slurm_t	self;
	HV *	conf;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_ctl_conf_2_key_pairs() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    conf = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::ctl_conf_2_key_pairs",
				"conf");
		}
	} STMT_END
;
#line 624 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_slurm_ctl_conf(conf, &cc) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_ctl_conf_2_key_pairs(&cc);
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 1821 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv( RETVALSV, "Slurm::List", (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_slurmd_status); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_slurmd_status)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
#line 646 "Slurm.xs"
		slurmd_status_t *status;
		int rc;
#line 1843 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_slurmd_status() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 649 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_slurmd_status(&status);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = slurmd_status_to_hv(status, RETVAL);
			slurm_free_slurmd_status(status);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 1874 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_slurmd_status); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_slurmd_status)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, out, slurmd_status");
    {
#line 672 "Slurm.xs"
		slurmd_status_t st;
#line 1895 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	slurmd_status;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_slurmd_status() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    slurmd_status = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::print_slurmd_status",
				"slurmd_status");
		}
	} STMT_END
;
#line 674 "Slurm.xs"
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if (hv_to_slurmd_status(slurmd_status, &st) < 0) {
			XSRETURN_UNDEF;
		}
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1936 "Slurm.c"

	slurm_print_slurmd_status(out, &st);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_key_pairs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_key_pairs)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "self, out, key_pairs, title");
    {
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	list_t *	key_pairs;
	char *	title = (char *)SvPV_nolen(ST(3))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_key_pairs() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) && sv_derived_from(ST(2), "Slurm::List")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		key_pairs = INT2PTR(list_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::print_key_pairs",
			"key_pairs", "Slurm::List");
	}
;
#line 691 "Slurm.xs"
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1986 "Slurm.c"

	slurm_print_key_pairs(out, key_pairs, title);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_update_step); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_update_step)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, step_msg");
    {
#line 705 "Slurm.xs"
		step_update_request_msg_t su_msg;
#line 2003 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	step_msg;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_update_step() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    step_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::update_step",
				"step_msg");
		}
	} STMT_END
;
#line 707 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_step_update_request_msg(step_msg, &su_msg) < 0) {
			RETVAL = SLURM_ERROR;
		} else {
			RETVAL = slurm_update_step(&su_msg);
		}
#line 2043 "Slurm.c"
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__job_info_msg_t_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__job_info_msg_t_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ji_msg");
    {
	job_info_msg_t *	ji_msg;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::job_info_msg_t")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ji_msg = INT2PTR(job_info_msg_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::job_info_msg_t::DESTROY",
			"ji_msg", "Slurm::job_info_msg_t");
	}
;
#line 728 "Slurm.xs"
		slurm_free_job_info_msg(ji_msg);
#line 2071 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_get_end_time); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_end_time)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
#line 738 "Slurm.xs"
		time_t tmp_time;
		int rc;
#line 2087 "Slurm.c"
	time_t	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_end_time() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 741 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_get_end_time(job_id, &tmp_time);
		if (rc == SLURM_SUCCESS) {
			RETVAL = tmp_time;
		} else {
			XSRETURN_UNDEF;
		}
#line 2115 "Slurm.c"
	XSprePUSH;
	PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_get_rem_time); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_rem_time)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
	long	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_rem_time() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 758 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 2151 "Slurm.c"

	RETVAL = slurm_get_rem_time(job_id);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_node_ready); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_node_ready)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_node_ready() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 769 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 2189 "Slurm.c"

	RETVAL = slurm_job_node_ready(job_id);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_job)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, job_id, show_flags=0");
    {
#line 783 "Slurm.xs"
		job_info_msg_t *ji_msg;
		int rc;
#line 2209 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_job() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 3)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(2))
;
	}
#line 786 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_job(&ji_msg, job_id, show_flags);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_info_msg_to_hv(ji_msg, RETVAL);
			/* cannot free ji_msg because RETVAL holds data in it */
			if (rc >= 0) {
				hv_store_ptr(RETVAL, "job_info_msg", ji_msg, "Slurm::job_info_msg_t");
			}
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 2253 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_jobs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_jobs)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "self, update_time=0, show_flags=0");
    {
#line 815 "Slurm.xs"
		job_info_msg_t *ji_msg;
		int rc;
#line 2275 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_jobs() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}

	if (items < 3)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(2))
;
	}
#line 818 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_jobs(update_time, &ji_msg, show_flags);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_info_msg_to_hv(ji_msg, RETVAL);
			/* cannot free ji_msg because RETVAL holds data in it */
			if (rc >= 0) {
				hv_store_ptr(RETVAL, "job_info_msg", ji_msg, "Slurm::job_info_msg_t");
			}
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 2325 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_notify_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_notify_job)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, message");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	char *	message = (char *)SvPV_nolen(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_notify_job() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 844 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 2367 "Slurm.c"

	RETVAL = slurm_notify_job(job_id, message);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_pid2jobid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_pid2jobid)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_pid");
    {
#line 858 "Slurm.xs"
		uint32_t tmp_pid;
		int rc;
#line 2387 "Slurm.c"
	uint32_t	RETVAL;
	dXSTARG;
	slurm_t	self;
	pid_t	job_pid = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_pid2jobid() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 861 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_pid2jobid(job_pid, &tmp_pid);
		if (rc == SLURM_SUCCESS) {
			RETVAL = tmp_pid;
		} else {
			XSRETURN_UNDEF;
		}
#line 2415 "Slurm.c"
	XSprePUSH;
	PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_update_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_update_job)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_info");
    {
#line 878 "Slurm.xs"
		job_desc_msg_t update_msg;
#line 2432 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	job_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_update_job() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    job_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::update_job",
				"job_info");
		}
	} STMT_END
;
#line 880 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_job_desc_msg(job_info, &update_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 2470 "Slurm.c"

	RETVAL = slurm_update_job(&update_msg);
	XSprePUSH;
	PUSHi((IV)RETVAL);
#line 891 "Slurm.xs"
		free_job_desc_msg_memory(&update_msg);
#line 2477 "Slurm.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_get_job_steps); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_job_steps)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 5)
       croak_xs_usage(cv,  "self, update_time=0, job_id=NO_VAL, step_id=NO_VAL, show_flags=0");
    {
#line 902 "Slurm.xs"
		int rc;
		job_step_info_response_msg_t *resp_msg;
#line 2493 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;
	uint32_t	job_id;
	uint32_t	step_id;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_job_steps() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}

	if (items < 3)
	    job_id = NO_VAL;
	else {
	    job_id = (unsigned long)SvUV(ST(2))
;
	}

	if (items < 4)
	    step_id = NO_VAL;
	else {
	    step_id = (unsigned long)SvUV(ST(3))
;
	}

	if (items < 5)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(4))
;
	}
#line 905 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_get_job_steps(update_time, job_id, step_id, &resp_msg, show_flags);
		if(rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_step_info_response_msg_to_hv(resp_msg, RETVAL);
			slurm_free_job_step_info_response_msg(resp_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 2556 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_job_step_info_msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_job_step_info_msg)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, step_info_msg, one_liner=0");
    {
#line 928 "Slurm.xs"
		job_step_info_response_msg_t si_msg;
#line 2577 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	step_info_msg;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_job_step_info_msg() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    step_info_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::print_job_step_info_msg",
				"step_info_msg");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 930 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_job_step_info_response_msg(step_info_msg, &si_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 2626 "Slurm.c"

	slurm_print_job_step_info_msg(out, &si_msg, one_liner);
#line 944 "Slurm.xs"
		xfree(si_msg.job_steps);
#line 2631 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_job_step_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_job_step_info)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, step_info, one_liner=0");
    {
#line 949 "Slurm.xs"
		job_step_info_t si;
#line 2646 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	step_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_job_step_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    step_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::print_job_step_info",
				"step_info");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 951 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_job_step_info(step_info, &si) < 0) {
			XSRETURN_UNDEF;
		}
#line 2695 "Slurm.c"

	slurm_print_job_step_info(out, &si, one_liner);
#line 965 "Slurm.xs"
		xfree(si.node_inx);
#line 2700 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_sprint_job_step_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_sprint_job_step_info)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, step_info, one_liner=0");
    {
#line 970 "Slurm.xs"
		job_step_info_t si;
#line 2715 "Slurm.c"
	char_xfree *	RETVAL;
	slurm_t	self;
	HV *	step_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_sprint_job_step_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    step_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::sprint_job_step_info",
				"step_info");
		}
	} STMT_END
;

	if (items < 3)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(2))
;
	}
#line 972 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_job_step_info(step_info, &si) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_sprint_job_step_info(&si, one_liner);
		xfree(si.node_inx);
#line 2762 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setpv ((SV*)RETVALSV, RETVAL);
	    xfree (RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_step_layout_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_step_layout_get)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, step_id_in");
    {
#line 988 "Slurm.xs"
		int rc;
		slurm_step_layout_t *layout;
		slurm_step_id_t step_id;
#line 2786 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id_in = (unsigned long)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_step_layout_get() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 992 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		step_id.job_id = job_id;
		step_id.step_id = step_id_in;
		layout = slurm_job_step_layout_get(&step_id);
		if(layout == NULL) {
			XSRETURN_UNDEF;
		} else {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = slurm_step_layout_to_hv(layout, RETVAL);
			slurm_job_step_layout_free(layout);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		}
#line 2823 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_step_stat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_step_stat)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 5)
       croak_xs_usage(cv,  "self, job_id, step_id_in, nodelist=NULL, protocol_version=NO_VAL16");
    {
#line 1017 "Slurm.xs"
		int rc;
		job_step_stat_response_msg_t *resp_msg = NULL;
		slurm_step_id_t step_id;
#line 2846 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id_in = (unsigned long)SvUV(ST(2))
;
	char *	nodelist;
	uint16_t	protocol_version;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_step_stat() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 4)
	    nodelist = NULL;
	else {
	    nodelist = (char *)SvPV_nolen(ST(3))
;
	}

	if (items < 5)
	    protocol_version = NO_VAL16;
	else {
	    protocol_version = (unsigned short)SvUV(ST(4))
;
	}
#line 1021 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		step_id.job_id = job_id;
		step_id.step_id = step_id_in;
		step_id.step_het_comp = NO_VAL;
                rc = slurm_job_step_stat(&step_id, nodelist,
					 protocol_version, &resp_msg);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_step_stat_response_msg_to_hv(resp_msg, RETVAL);
			slurm_job_step_stat_response_msg_free(resp_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			errno = rc;
			XSRETURN_UNDEF;
		}
#line 2902 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_step_get_pids); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_step_get_pids)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, job_id, step_id_in, nodelist=NULL");
    {
#line 1049 "Slurm.xs"
		int rc;
		job_step_pids_response_msg_t *resp_msg = NULL;
		slurm_step_id_t step_id;
#line 2925 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id_in = (unsigned long)SvUV(ST(2))
;
	char *	nodelist;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_step_get_pids() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 4)
	    nodelist = NULL;
	else {
	    nodelist = (char *)SvPV_nolen(ST(3))
;
	}
#line 1053 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		step_id.job_id = job_id;
		step_id.step_id = step_id_in;
		step_id.step_het_comp = NO_VAL;
		rc = slurm_job_step_get_pids(&step_id, nodelist, &resp_msg);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_step_pids_response_msg_to_hv(resp_msg, RETVAL);
			slurm_job_step_pids_response_msg_free(resp_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			errno = rc;
			XSRETURN_UNDEF;
		}
#line 2972 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__node_info_msg_t_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__node_info_msg_t_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ni_msg");
    {
	node_info_msg_t *	ni_msg;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::node_info_msg_t")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ni_msg = INT2PTR(node_info_msg_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::node_info_msg_t::DESTROY",
			"ni_msg", "Slurm::node_info_msg_t");
	}
;
#line 1085 "Slurm.xs"
		slurm_free_node_info_msg(ni_msg);
#line 3004 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_load_node); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_node)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "self, update_time=0, show_flags=0");
    {
#line 1094 "Slurm.xs"
		node_info_msg_t *ni_msg = NULL;
		int rc;
#line 3020 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_node() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}

	if (items < 3)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(2))
;
	}
#line 1097 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_node(update_time, &ni_msg,
				     show_flags | SHOW_MIXED);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			/* RETVAL holds ni_msg->select_nodeinfo, so delay free-ing the msg */
			rc = node_info_msg_to_hv(ni_msg, RETVAL);
			if (rc >= 0) {
				rc = hv_store_ptr(RETVAL, "node_info_msg", ni_msg, "Slurm::node_info_msg_t");
			}
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 3071 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_single_node); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_single_node)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, node_name, show_flags=0");
    {
#line 1124 "Slurm.xs"
		node_info_msg_t *ni_msg = NULL;
		int rc;
#line 3093 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	char *	node_name = (char *)SvPV_nolen(ST(1))
;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_single_node() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 3)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(2))
;
	}
#line 1127 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_node_single(&ni_msg, node_name, show_flags | SHOW_MIXED);

		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			/* RETVAL holds ni_msg->select_nodeinfo, so delay free-ing the msg */
			rc = node_info_msg_to_hv(ni_msg, RETVAL);
			if (rc >= 0) {
				rc = hv_store_ptr(RETVAL, "node_info_msg", ni_msg, "Slurm::node_info_msg_t");
			}
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 3138 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_node_info_msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_node_info_msg)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, node_info_msg, one_liner=0");
    {
#line 1154 "Slurm.xs"
		node_info_msg_t ni_msg;
#line 3159 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	node_info_msg;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_node_info_msg() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    node_info_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::print_node_info_msg",
				"node_info_msg");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1156 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_node_info_msg(node_info_msg, &ni_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 3208 "Slurm.c"

	slurm_print_node_info_msg(out, &ni_msg, one_liner);
#line 1170 "Slurm.xs"
		xfree(ni_msg.node_array);
#line 3213 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_node_table); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_node_table)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, node_info, one_liner=0");
    {
#line 1175 "Slurm.xs"
		node_info_t ni;
#line 3228 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	node_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_node_table() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    node_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::print_node_table",
				"node_info");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1177 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_node_info(node_info, &ni) < 0) {
			XSRETURN_UNDEF;
		}
#line 3277 "Slurm.c"

	slurm_print_node_table(out, &ni, one_liner);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_sprint_node_table); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_sprint_node_table)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, node_info, one_liner=0");
    {
#line 1194 "Slurm.xs"
		node_info_t ni;
#line 3294 "Slurm.c"
	char_xfree *	RETVAL;
	slurm_t	self;
	HV *	node_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_sprint_node_table() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    node_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::sprint_node_table",
				"node_info");
		}
	} STMT_END
;

	if (items < 3)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(2))
;
	}
#line 1196 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_node_info(node_info, &ni) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_sprint_node_table(&ni, one_liner);
#line 3340 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setpv ((SV*)RETVALSV, RETVAL);
	    xfree (RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_update_node); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_update_node)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, update_req");
    {
#line 1211 "Slurm.xs"
		update_node_msg_t node_msg;
#line 3362 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	update_req;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_update_node() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    update_req = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::update_node",
				"update_req");
		}
	} STMT_END
;
#line 1213 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_update_node_msg(update_req, &node_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 3400 "Slurm.c"

	RETVAL = slurm_update_node(&node_msg);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_topo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_topo)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
#line 1232 "Slurm.xs"
		topo_info_response_msg_t *topo_info_msg = NULL;
		int rc;
#line 3420 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_topo() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1235 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_topo( &topo_info_msg);
		if(rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = topo_info_response_msg_to_hv(topo_info_msg, RETVAL);
			slurm_free_topo_info_msg(topo_info_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 3451 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_topo_info_msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_topo_info_msg)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "self, out, topo_info_msg, node_list, one_liner=0");
    {
#line 1258 "Slurm.xs"
		topo_info_response_msg_t ti_msg;
#line 3472 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	topo_info_msg;
	char *	node_list = (char *)SvPV_nolen(ST(3))
;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_topo_info_msg() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    topo_info_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::print_topo_info_msg",
				"topo_info_msg");
		}
	} STMT_END
;

	if (items < 5)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(4))
;
	}
#line 1260 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_topo_info_response_msg(topo_info_msg, &ti_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 3523 "Slurm.c"

	slurm_print_topo_info_msg(out, &ti_msg, node_list, one_liner);
#line 1274 "Slurm.xs"
		xfree(ti_msg.topo_array);
#line 3528 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_get_select_nodeinfo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_select_nodeinfo)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "self, nodeinfo, data_type, state, data");
    {
#line 1285 "Slurm.xs"
		uint16_t tmp_16;
		select_nodeinfo_t *tmp_ptr;
#line 3544 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	dynamic_plugin_data_t *	nodeinfo;
	uint32_t	data_type = (unsigned long)SvUV(ST(2))
;
	uint32_t	state = (unsigned long)SvUV(ST(3))
;
	SV *	data = ST(4)
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_select_nodeinfo() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::dynamic_plugin_data_t")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		nodeinfo = INT2PTR(dynamic_plugin_data_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::get_select_nodeinfo",
			"nodeinfo", "Slurm::dynamic_plugin_data_t");
	}
;
#line 1288 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		switch(data_type) {
		case SELECT_NODEDATA_SUBCNT:      /* data-> uint16_t */
			RETVAL = slurm_get_select_nodeinfo(nodeinfo, data_type, state, &tmp_16);
			if (RETVAL == 0) {
				sv_setuv(data, (UV)tmp_16);
			}
			break;
		case SELECT_NODEDATA_PTR:         /* data-> select_nodeinfo_t *nodeinfo */
			RETVAL = slurm_get_select_nodeinfo(nodeinfo, data_type, state, &tmp_ptr);
			if (RETVAL == 0) {
				sv_setref_pv(data, "Slurm::select_nodeinfo_t", (void*)tmp_ptr);
			}
			break;
		default:
			RETVAL = slurm_get_select_nodeinfo(nodeinfo, data_type, state, NULL);
		}
#line 3597 "Slurm.c"
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_partitions); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_partitions)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "self, update_time=0, show_flags=0");
    {
#line 1319 "Slurm.xs"
		partition_info_msg_t *part_info_msg;
		int rc;
#line 3615 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_partitions() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}

	if (items < 3)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(2))
;
	}
#line 1322 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_partitions(update_time, &part_info_msg,
					   show_flags);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = partition_info_msg_to_hv(part_info_msg, RETVAL);
			slurm_free_partition_info_msg(part_info_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 3663 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_partition_info_msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_partition_info_msg)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, part_info_msg, one_liner=0");
    {
#line 1346 "Slurm.xs"
		partition_info_msg_t pi_msg;
#line 3684 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	part_info_msg;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_partition_info_msg() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    part_info_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::print_partition_info_msg",
				"part_info_msg");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1348 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_partition_info_msg(part_info_msg, &pi_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 3733 "Slurm.c"

	slurm_print_partition_info_msg(out, &pi_msg, one_liner);
#line 1362 "Slurm.xs"
		xfree(pi_msg.partition_array);
#line 3738 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_partition_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_partition_info)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, part_info, one_liner=0");
    {
#line 1367 "Slurm.xs"
		partition_info_t pi;
#line 3753 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	part_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_partition_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    part_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::print_partition_info",
				"part_info");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1369 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_partition_info(part_info, &pi) < 0) {
			XSRETURN_UNDEF;
		}
#line 3802 "Slurm.c"

	slurm_print_partition_info(out, &pi, one_liner);
#line 1383 "Slurm.xs"
		xfree(pi.node_inx);
#line 3807 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_sprint_partition_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_sprint_partition_info)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, part_info, one_liner=0");
    {
#line 1388 "Slurm.xs"
		partition_info_t pi;
#line 3822 "Slurm.c"
	char_xfree *	RETVAL;
	slurm_t	self;
	HV *	part_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_sprint_partition_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    part_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::sprint_partition_info",
				"part_info");
		}
	} STMT_END
;

	if (items < 3)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(2))
;
	}
#line 1390 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_partition_info(part_info, &pi) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_sprint_partition_info(&pi, one_liner);
		xfree(pi.node_inx);
#line 3869 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setpv ((SV*)RETVALSV, RETVAL);
	    xfree (RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_create_partition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_create_partition)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, part_info");
    {
#line 1406 "Slurm.xs"
		update_part_msg_t update_msg;
#line 3891 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	part_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_create_partition() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    part_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::create_partition",
				"part_info");
		}
	} STMT_END
;
#line 1408 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_update_part_msg(part_info, &update_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 3929 "Slurm.c"

	RETVAL = slurm_create_partition(&update_msg);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_update_partition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_update_partition)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, part_info");
    {
#line 1422 "Slurm.xs"
		update_part_msg_t update_msg;
#line 3948 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	part_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_update_partition() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    part_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::update_partition",
				"part_info");
		}
	} STMT_END
;
#line 1424 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_update_part_msg(part_info, &update_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 3986 "Slurm.c"

	RETVAL = slurm_update_partition(&update_msg);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_delete_partition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_delete_partition)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, delete_part_msg");
    {
#line 1438 "Slurm.xs"
		delete_part_msg_t dp_msg;
#line 4005 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	delete_part_msg;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_delete_partition() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    delete_part_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::delete_partition",
				"delete_part_msg");
		}
	} STMT_END
;
#line 1440 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_delete_part_msg(delete_part_msg, &dp_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 4043 "Slurm.c"

	RETVAL = slurm_delete_partition(&dp_msg);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_reservations); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_reservations)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, update_time=0");
    {
#line 1459 "Slurm.xs"
		reserve_info_msg_t *resv_info_msg = NULL;
		int rc;
#line 4063 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_reservations() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}
#line 1462 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_reservations(update_time, &resv_info_msg);
		if(rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = reserve_info_msg_to_hv(resv_info_msg, RETVAL);
			slurm_free_reservation_info_msg(resv_info_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 4102 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_create_reservation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_create_reservation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, res_info");
    {
#line 1485 "Slurm.xs"
		resv_desc_msg_t resv_msg;
#line 4123 "Slurm.c"
	char_free *	RETVAL;
	slurm_t	self;
	HV *	res_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_create_reservation() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    res_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::create_reservation",
				"res_info");
		}
	} STMT_END
;
#line 1487 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_update_reservation_msg(res_info, &resv_msg) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_create_reservation(&resv_msg);
		if (RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 4164 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setpv ((SV*)RETVALSV, RETVAL);
	    free (RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_update_reservation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_update_reservation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, res_info");
    {
#line 1505 "Slurm.xs"
		resv_desc_msg_t resv_msg;
#line 4186 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	res_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_update_reservation() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    res_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::update_reservation",
				"res_info");
		}
	} STMT_END
;
#line 1507 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_update_reservation_msg(res_info, &resv_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 4224 "Slurm.c"

	RETVAL = slurm_update_reservation(&resv_msg);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_delete_reservation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_delete_reservation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, res_info");
    {
#line 1521 "Slurm.xs"
		reservation_name_msg_t resv_name;
#line 4243 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	res_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_delete_reservation() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    res_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::delete_reservation",
				"res_info");
		}
	} STMT_END
;
#line 1523 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_delete_reservation_msg(res_info, &resv_name) < 0) {
			XSRETURN_UNDEF;
		}
#line 4281 "Slurm.c"

	RETVAL = slurm_delete_reservation(&resv_name);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_reservation_info_msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_reservation_info_msg)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, resv_info_msg, one_liner=0");
    {
#line 1537 "Slurm.xs"
		reserve_info_msg_t ri_msg;
		int i;
#line 4301 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	resv_info_msg;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_reservation_info_msg() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    resv_info_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::print_reservation_info_msg",
				"resv_info_msg");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1540 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_reserve_info_msg(resv_info_msg, &ri_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 4350 "Slurm.c"

	slurm_print_reservation_info_msg(out, &ri_msg, one_liner);
#line 1554 "Slurm.xs"
		for (i = 0; i < ri_msg.record_count; i ++)
			xfree(ri_msg.reservation_array[i]);
		xfree(ri_msg.reservation_array);
#line 4357 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_reservation_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_reservation_info)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, resv_info, one_liner=0");
    {
#line 1561 "Slurm.xs"
		reserve_info_t ri;
#line 4372 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	resv_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_reservation_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    resv_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::print_reservation_info",
				"resv_info");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1563 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_reserve_info(resv_info, &ri) < 0) {
			XSRETURN_UNDEF;
		}
#line 4421 "Slurm.c"

	slurm_print_reservation_info(out, &ri, one_liner);
#line 1577 "Slurm.xs"
		xfree(ri.node_inx);
#line 4426 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_sprint_reservation_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_sprint_reservation_info)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, resv_info, one_liner=0");
    {
#line 1582 "Slurm.xs"
		reserve_info_t ri;
#line 4441 "Slurm.c"
	char_xfree *	RETVAL;
	slurm_t	self;
	HV *	resv_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_sprint_reservation_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    resv_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::sprint_reservation_info",
				"resv_info");
		}
	} STMT_END
;

	if (items < 3)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(2))
;
	}
#line 1584 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_reserve_info(resv_info, &ri) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_sprint_reservation_info(&ri, one_liner);
		xfree(ri.node_inx);
#line 4488 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setpv ((SV*)RETVALSV, RETVAL);
	    xfree (RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_ping); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_ping)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, primary=0");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint16_t	primary;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_ping() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    primary = 0;
	else {
	    primary = (unsigned short)SvUV(ST(1))
;
	}
#line 1605 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 4535 "Slurm.c"

	RETVAL = slurm_ping(primary);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_reconfigure); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_reconfigure)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_reconfigure() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1616 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 4571 "Slurm.c"

	RETVAL = slurm_reconfigure();
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_shutdown); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_shutdown)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, options=0");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint16_t	options;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_shutdown() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    options = 0;
	else {
	    options = (unsigned short)SvUV(ST(1))
;
	}
#line 1626 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 4615 "Slurm.c"

	RETVAL = slurm_shutdown(options);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_takeover); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_takeover)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, backup_inx=1");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	int	backup_inx;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_takeover() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    backup_inx = 1;
	else {
	    backup_inx = (int)SvIV(ST(1))
;
	}
#line 1637 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 4659 "Slurm.c"

	RETVAL = slurm_takeover(backup_inx);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_set_debug_level); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_set_debug_level)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, debug_level");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	debug_level = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_set_debug_level() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1648 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 4697 "Slurm.c"

	RETVAL = slurm_set_debug_level(debug_level);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_set_schedlog_level); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_set_schedlog_level)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, schedlog_level");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	schedlog_level = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_set_schedlog_level() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1659 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 4735 "Slurm.c"

	RETVAL = slurm_set_schedlog_level(schedlog_level);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_suspend); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_suspend)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_suspend() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1675 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 4773 "Slurm.c"

	RETVAL = slurm_suspend(job_id);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_resume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_resume)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_resume() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1686 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 4811 "Slurm.c"

	RETVAL = slurm_resume(job_id);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_requeue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_requeue)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, state");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	state = (unsigned long)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_requeue() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1697 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 4851 "Slurm.c"

	RETVAL = slurm_requeue(job_id, state);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_set_trigger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_set_trigger)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, trigger_info");
    {
#line 1712 "Slurm.xs"
		trigger_info_t ti;
#line 4870 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	trigger_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_set_trigger() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    trigger_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::set_trigger",
				"trigger_info");
		}
	} STMT_END
;
#line 1714 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
	       if(hv_to_trigger_info(trigger_info, &ti) < 0) {
			XSRETURN_UNDEF;
		}
#line 4908 "Slurm.c"

	RETVAL = slurm_set_trigger(&ti);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_clear_trigger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_clear_trigger)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, trigger_info");
    {
#line 1727 "Slurm.xs"
		trigger_info_t ti;
#line 4927 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	trigger_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_clear_trigger() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    trigger_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::clear_trigger",
				"trigger_info");
		}
	} STMT_END
;
#line 1729 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_trigger_info(trigger_info, &ti) < 0) {
			XSRETURN_UNDEF;
		}
#line 4965 "Slurm.c"

	RETVAL = slurm_clear_trigger(&ti);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_get_triggers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_triggers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
#line 1743 "Slurm.xs"
		trigger_info_msg_t *ti_msg;
		int rc;
#line 4985 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_triggers() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1746 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_get_triggers(&ti_msg);
		if(rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = trigger_info_msg_to_hv(ti_msg, RETVAL);
			slurm_free_trigger_msg(ti_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 5016 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_pull_trigger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_pull_trigger)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, trigger_info");
    {
#line 1769 "Slurm.xs"
		trigger_info_t ti;
#line 5037 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	trigger_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_pull_trigger() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    trigger_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not a HASH reference",
				"Slurm::pull_trigger",
				"trigger_info");
		}
	} STMT_END
;
#line 1771 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_trigger_info(trigger_info, &ti) < 0) {
			XSRETURN_UNDEF;
		}
#line 5075 "Slurm.c"

	RETVAL = slurm_pull_trigger(&ti);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_create)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hostlist");
    {
	hostlist_t *	RETVAL;
	char *	hostlist = (char *)SvPV_nolen(ST(0))
;

	RETVAL = slurm_hostlist_create(hostlist);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv( RETVALSV, "Slurm::Hostlist", (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hl");
    {
	int	RETVAL;
	dXSTARG;
	hostlist_t *	hl;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::count",
			"hl", "Slurm::Hostlist");
	}
;

	RETVAL = slurm_hostlist_count(hl);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_find); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_find)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "hl, hostname");
    {
	int	RETVAL;
	dXSTARG;
	hostlist_t *	hl;
	char *	hostname = (char *)SvPV_nolen(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::find",
			"hl", "Slurm::Hostlist");
	}
;

	RETVAL = slurm_hostlist_find(hl, hostname);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_push); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_push)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "hl, hosts");
    {
	int	RETVAL;
	dXSTARG;
	hostlist_t *	hl;
	char *	hosts = (char *)SvPV_nolen(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::push",
			"hl", "Slurm::Hostlist");
	}
;

	RETVAL = slurm_hostlist_push(hl, hosts);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_push_host); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_push_host)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "hl, host");
    {
	int	RETVAL;
	dXSTARG;
	hostlist_t *	hl;
	char *	host = (char *)SvPV_nolen(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::push_host",
			"hl", "Slurm::Hostlist");
	}
;

	RETVAL = slurm_hostlist_push_host(hl, host);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_ranged_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_ranged_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hl");
    {
	char_xfree *	RETVAL;
	hostlist_t *	hl;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::ranged_string",
			"hl", "Slurm::Hostlist");
	}
;
#line 1799 "Slurm.xs"
		RETVAL = slurm_hostlist_ranged_string_xmalloc(hl);
		if (RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 5254 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setpv ((SV*)RETVALSV, RETVAL);
	    xfree (RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_shift); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_shift)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "hl= NULL");
    {
	char_free *	RETVAL;
	hostlist_t *	hl;

	if (items < 1)
	    hl = NULL;
	else {
	    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		    IV tmp = SvIV((SV*)SvRV(ST(0)));
		    hl = INT2PTR(hostlist_t *,tmp);
	    } else {
		    Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Slurm::Hostlist::shift",
			    "hl", "Slurm::Hostlist");
	    }
;
	}
#line 1808 "Slurm.xs"
		RETVAL = slurm_hostlist_shift(hl);
		if (RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 5295 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setpv ((SV*)RETVALSV, RETVAL);
	    free (RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_uniq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_uniq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hl");
    {
	hostlist_t *	hl;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::uniq",
			"hl", "Slurm::Hostlist");
	}
;

	slurm_hostlist_uniq(hl);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Hostlist_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hl");
    {
	hostlist_t *	hl;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::DESTROY",
			"hl", "Slurm::Hostlist");
	}
;
#line 1819 "Slurm.xs"
		slurm_hostlist_destroy(hl);
#line 5353 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__List_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__List_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "l");
    {
	int	RETVAL;
	dXSTARG;
	list_t *	l;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::List")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		l = INT2PTR(list_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::List::count",
			"l", "Slurm::List");
	}
;

	RETVAL = slurm_list_count(l);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__List_is_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__List_is_empty)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "l");
    {
	int	RETVAL;
	dXSTARG;
	list_t *	l;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::List")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		l = INT2PTR(list_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::List::is_empty",
			"l", "Slurm::List");
	}
;

	RETVAL = slurm_list_is_empty(l);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__List_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__List_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "l");
    {
	list_t *	l;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::List")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		l = INT2PTR(list_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::List::DESTROY",
			"l", "Slurm::List");
	}
;
#line 1847 "Slurm.xs"
		slurm_list_destroy(l);
#line 5437 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__ListIterator_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__ListIterator_create)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "l");
    {
	list_itr_t *	RETVAL;
	list_t *	l;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::List")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		l = INT2PTR(list_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::ListIterator::create",
			"l", "Slurm::List");
	}
;

	RETVAL = slurm_list_iterator_create(l);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv( RETVALSV, "Slurm::ListIterator", (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__ListIterator_reset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__ListIterator_reset)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	list_itr_t *	i;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::ListIterator")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		i = INT2PTR(list_itr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::ListIterator::reset",
			"i", "Slurm::ListIterator");
	}
;

	slurm_list_iterator_reset(i);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__ListIterator_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__ListIterator_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	list_itr_t *	i;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::ListIterator")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		i = INT2PTR(list_itr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::ListIterator::DESTROY",
			"i", "Slurm::ListIterator");
	}
;
#line 1875 "Slurm.xs"
		slurm_list_iterator_destroy(i);
#line 5520 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_alloc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_alloc)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "nbits");
    {
	bitstr_t *	RETVAL;
	bitoff_t	nbits = (bitoff_t)SvIV(ST(0))
;

	RETVAL = slurm_bit_alloc(nbits);
#line 1887 "Slurm.xs"
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 5542 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv( RETVALSV, "Slurm::Bitstr", (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_copy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_copy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitstr_t *	RETVAL;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::copy",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_copy(b);
#line 1894 "Slurm.xs"
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 5579 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv( RETVALSV, "Slurm::Bitstr", (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_test); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_test)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, bit");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	bitoff_t	bit = (bitoff_t)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::test",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_test(b, bit);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_set)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, bit");
    {
	bitstr_t *	b;
	bitoff_t	bit = (bitoff_t)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::set",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_set(b, bit);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_clear)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, bit");
    {
	bitstr_t *	b;
	bitoff_t	bit = (bitoff_t)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::clear",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_clear(b, bit);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_nset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_nset)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "b, start, stop");
    {
	bitstr_t *	b;
	bitoff_t	start = (bitoff_t)SvIV(ST(1))
;
	bitoff_t	stop = (bitoff_t)SvIV(ST(2))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::nset",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_nset(b, start, stop);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_nclear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_nclear)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "b, start, stop");
    {
	bitstr_t *	b;
	bitoff_t	start = (bitoff_t)SvIV(ST(1))
;
	bitoff_t	stop = (bitoff_t)SvIV(ST(2))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::nclear",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_nclear(b, start, stop);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_ffc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_ffc)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::ffc",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_ffc(b);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_ffs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_ffs)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::ffs",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_ffs(b);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_fls); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_fls)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::fls",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_fls(b);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_nffc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_nffc)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, n");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	int	n = (int)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::nffc",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_nffc(b, n);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_nffs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_nffs)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, n");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	int	n = (int)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::nffs",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_nffs(b, n);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_noc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_noc)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "b, n, seed");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	int	n = (int)SvIV(ST(1))
;
	int	seed = (int)SvIV(ST(2))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::noc",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_noc(b, n, seed);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::size",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_size(b);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_and); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_and)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::and",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::and",
			"b2", "Slurm::Bitstr");
	}
;

	slurm_bit_and(b1, b2);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_not); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_not)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::not",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_not(b);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_or); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_or)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::or",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::or",
			"b2", "Slurm::Bitstr");
	}
;

	slurm_bit_or(b1, b2);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_copybits); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_copybits)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::copybits",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::copybits",
			"b2", "Slurm::Bitstr");
	}
;

	slurm_bit_copybits(b1, b2);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_set_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_set_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::set_count",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_set_count(b);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_set_count_range); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_set_count_range)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "b, start, end");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	int	start = (int)SvIV(ST(1))
;
	int	end = (int)SvIV(ST(2))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::set_count_range",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_set_count_range(b, start, end);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_clear_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_clear_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::clear_count",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_clear_count(b);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_nset_max_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_nset_max_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::nset_max_count",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_nset_max_count(b);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_rotate_copy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_rotate_copy)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "b, n, nbits");
    {
	bitstr_t *	RETVAL;
	bitstr_t *	b;
	int	n = (int)SvIV(ST(1))
;
	bitoff_t	nbits = (bitoff_t)SvIV(ST(2))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::rotate_copy",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_rotate_copy(b, n, nbits);
#line 1961 "Slurm.xs"
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 6227 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv( RETVALSV, "Slurm::Bitstr", (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_rotate)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, n");
    {
	bitstr_t *	b;
	int	n = (int)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::rotate",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_rotate(b, n);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_fmt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_fmt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
#line 1973 "Slurm.xs"
		int len = 1, bits;
		char *tmp_str;
#line 6276 "Slurm.c"
	char *	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::fmt",
			"b", "Slurm::Bitstr");
	}
;
#line 1976 "Slurm.xs"
		bits = slurm_bit_size(b);
		while(bits > 0) {
			bits /= 10;
			len ++;
		}
		bits = slurm_bit_size(b);
		len *= bits;
		New(0, tmp_str, len, char);
		slurm_bit_fmt(tmp_str, len, b);
		len = strlen(tmp_str) + 1;
		New(0, RETVAL, len, char);
		Copy(tmp_str, RETVAL, len, char);
		Safefree(tmp_str);
#line 6304 "Slurm.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_unfmt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_unfmt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, str");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	char *	str = (char *)SvPV_nolen(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::unfmt",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_unfmt(b, str);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_fmt2int); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_fmt2int)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
#line 2000 "Slurm.xs"
		int i = 0, *array;
#line 6353 "Slurm.c"
	AV *	RETVAL;
	char *	str = (char *)SvPV_nolen(ST(0))
;
#line 2002 "Slurm.xs"
		array = slurm_bitfmt2int(str);
		RETVAL = newAV();
		while (array[i] != -1) {
			av_store_int(RETVAL, i, array[i]);
			i ++;
		}
		xfree(array);
#line 6365 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_fmt_hexmask); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_fmt_hexmask)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
#line 2016 "Slurm.xs"
		char *tmp_str;
		int len;
#line 6387 "Slurm.c"
	char *	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::fmt_hexmask",
			"b", "Slurm::Bitstr");
	}
;
#line 2019 "Slurm.xs"
		tmp_str = slurm_bit_fmt_hexmask(b);
		len = strlen(tmp_str) + 1;
		New(0, RETVAL, len, char);
		Copy(tmp_str, RETVAL, len, char);
		xfree(tmp_str);
#line 6407 "Slurm.c"
	sv_setpv(TARG, RETVAL);
	XSprePUSH;
	PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_unfmt_hexmask); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_unfmt_hexmask)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, str");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	char *	str = (char *)SvPV_nolen(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::unfmt_hexmask",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_unfmt_hexmask(b, str);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_fill_gaps); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_fill_gaps)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::fill_gaps",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_fill_gaps(b);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_super_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_super_set)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::super_set",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::super_set",
			"b2", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_super_set(b1, b2);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_overlap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_overlap)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::overlap",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::overlap",
			"b2", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_overlap(b1, b2);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_equal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_equal)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::equal",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::equal",
			"b2", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_equal(b1, b2);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_pick_cnt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_pick_cnt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, nbits");
    {
	bitstr_t *	RETVAL;
	bitstr_t *	b;
	bitoff_t	nbits = (bitoff_t)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::pick_cnt",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_pick_cnt(b, nbits);
#line 2048 "Slurm.xs"
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 6619 "Slurm.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv( RETVALSV, "Slurm::Bitstr", (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_get_bit_num); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_get_bit_num)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, pos");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	int	pos = (int)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::get_bit_num",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_get_bit_num(b, pos);
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::DESTROY",
			"b", "Slurm::Bitstr");
	}
;
#line 2058 "Slurm.xs"
		FREE_NULL_BITMAP(b);
#line 6682 "Slurm.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C" {
#endif
XS_EXTERNAL(boot_Slurm); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Slurm)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if PERL_VERSION_LE(5, 8, 999) /* PERL_VERSION_LT is 5.33+ */
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("Slurm::new", XS_Slurm_new, file, "");
        (void)newXSproto_portable("Slurm::DESTROY", XS_Slurm_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::get_errno", XS_Slurm_get_errno, file, "$");
        (void)newXSproto_portable("Slurm::strerror", XS_Slurm_strerror, file, "$;$");
        (void)newXSproto_portable("Slurm::preempt_mode_string", XS_Slurm_preempt_mode_string, file, "$$");
        (void)newXSproto_portable("Slurm::preempt_mode_num", XS_Slurm_preempt_mode_num, file, "$$");
        (void)newXSproto_portable("Slurm::job_reason_string", XS_Slurm_job_reason_string, file, "$$");
        (void)newXSproto_portable("Slurm::job_state_string", XS_Slurm_job_state_string, file, "$$");
        (void)newXSproto_portable("Slurm::job_state_string_compact", XS_Slurm_job_state_string_compact, file, "$$");
        (void)newXSproto_portable("Slurm::job_state_num", XS_Slurm_job_state_num, file, "$$");
        (void)newXSproto_portable("Slurm::reservation_flags_string", XS_Slurm_reservation_flags_string, file, "$$");
        (void)newXSproto_portable("Slurm::node_state_string", XS_Slurm_node_state_string, file, "$$");
        (void)newXSproto_portable("Slurm::node_state_string_compact", XS_Slurm_node_state_string_compact, file, "$$");
        (void)newXSproto_portable("Slurm::private_data_string", XS_Slurm_private_data_string, file, "$$");
        (void)newXSproto_portable("Slurm::accounting_enforce_string", XS_Slurm_accounting_enforce_string, file, "$$");
        (void)newXSproto_portable("Slurm::allocate_resources", XS_Slurm_allocate_resources, file, "$$");
        (void)newXSproto_portable("Slurm::allocate_resources_blocking", XS_Slurm_allocate_resources_blocking, file, "$$;$$");
        (void)newXSproto_portable("Slurm::allocation_lookup", XS_Slurm_allocation_lookup, file, "$$");
        (void)newXSproto_portable("Slurm::read_hostfile", XS_Slurm_read_hostfile, file, "$$$");
        (void)newXSproto_portable("Slurm::allocation_msg_thr_create", XS_Slurm_allocation_msg_thr_create, file, "$$$");
        (void)newXSproto_portable("Slurm::allocation_msg_thr_destroy", XS_Slurm_allocation_msg_thr_destroy, file, "$$");
        (void)newXSproto_portable("Slurm::submit_batch_job", XS_Slurm_submit_batch_job, file, "$$");
        (void)newXSproto_portable("Slurm::job_will_run", XS_Slurm_job_will_run, file, "$$");
        (void)newXSproto_portable("Slurm::sbcast_lookup", XS_Slurm_sbcast_lookup, file, "$$$");
        (void)newXSproto_portable("Slurm::kill_job", XS_Slurm_kill_job, file, "$$$;$");
        (void)newXSproto_portable("Slurm::kill_job_step", XS_Slurm_kill_job_step, file, "$$$$$");
        (void)newXSproto_portable("Slurm::signal_job", XS_Slurm_signal_job, file, "$$$");
        (void)newXSproto_portable("Slurm::signal_job_step", XS_Slurm_signal_job_step, file, "$$$$");
        (void)newXSproto_portable("Slurm::complete_job", XS_Slurm_complete_job, file, "$$;$");
        (void)newXSproto_portable("Slurm::terminate_job_step", XS_Slurm_terminate_job_step, file, "$$$");
        (void)newXSproto_portable("Slurm::api_version", XS_Slurm_api_version, file, "$");
        (void)newXSproto_portable("Slurm::load_ctl_conf", XS_Slurm_load_ctl_conf, file, "$;$");
        (void)newXSproto_portable("Slurm::print_ctl_conf", XS_Slurm_print_ctl_conf, file, "$$$");
        (void)newXSproto_portable("Slurm::ctl_conf_2_key_pairs", XS_Slurm_ctl_conf_2_key_pairs, file, "$$");
        (void)newXSproto_portable("Slurm::load_slurmd_status", XS_Slurm_load_slurmd_status, file, "$");
        (void)newXSproto_portable("Slurm::print_slurmd_status", XS_Slurm_print_slurmd_status, file, "$$$");
        (void)newXSproto_portable("Slurm::print_key_pairs", XS_Slurm_print_key_pairs, file, "$$$$");
        (void)newXSproto_portable("Slurm::update_step", XS_Slurm_update_step, file, "$$");
        (void)newXSproto_portable("Slurm::job_info_msg_t::DESTROY", XS_Slurm__job_info_msg_t_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::get_end_time", XS_Slurm_get_end_time, file, "$$");
        (void)newXSproto_portable("Slurm::get_rem_time", XS_Slurm_get_rem_time, file, "$$");
        (void)newXSproto_portable("Slurm::job_node_ready", XS_Slurm_job_node_ready, file, "$$");
        (void)newXSproto_portable("Slurm::load_job", XS_Slurm_load_job, file, "$$;$");
        (void)newXSproto_portable("Slurm::load_jobs", XS_Slurm_load_jobs, file, "$;$$");
        (void)newXSproto_portable("Slurm::notify_job", XS_Slurm_notify_job, file, "$$$");
        (void)newXSproto_portable("Slurm::pid2jobid", XS_Slurm_pid2jobid, file, "$$");
        (void)newXSproto_portable("Slurm::update_job", XS_Slurm_update_job, file, "$$");
        (void)newXSproto_portable("Slurm::get_job_steps", XS_Slurm_get_job_steps, file, "$;$$$$");
        (void)newXSproto_portable("Slurm::print_job_step_info_msg", XS_Slurm_print_job_step_info_msg, file, "$$$;$");
        (void)newXSproto_portable("Slurm::print_job_step_info", XS_Slurm_print_job_step_info, file, "$$$;$");
        (void)newXSproto_portable("Slurm::sprint_job_step_info", XS_Slurm_sprint_job_step_info, file, "$$;$");
        (void)newXSproto_portable("Slurm::job_step_layout_get", XS_Slurm_job_step_layout_get, file, "$$$");
        (void)newXSproto_portable("Slurm::job_step_stat", XS_Slurm_job_step_stat, file, "$$$;$$");
        (void)newXSproto_portable("Slurm::job_step_get_pids", XS_Slurm_job_step_get_pids, file, "$$$;$");
        (void)newXSproto_portable("Slurm::node_info_msg_t::DESTROY", XS_Slurm__node_info_msg_t_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::load_node", XS_Slurm_load_node, file, "$;$$");
        (void)newXSproto_portable("Slurm::load_single_node", XS_Slurm_load_single_node, file, "$$;$");
        (void)newXSproto_portable("Slurm::print_node_info_msg", XS_Slurm_print_node_info_msg, file, "$$$;$");
        (void)newXSproto_portable("Slurm::print_node_table", XS_Slurm_print_node_table, file, "$$$;$");
        (void)newXSproto_portable("Slurm::sprint_node_table", XS_Slurm_sprint_node_table, file, "$$;$");
        (void)newXSproto_portable("Slurm::update_node", XS_Slurm_update_node, file, "$$");
        (void)newXSproto_portable("Slurm::load_topo", XS_Slurm_load_topo, file, "$");
        (void)newXSproto_portable("Slurm::print_topo_info_msg", XS_Slurm_print_topo_info_msg, file, "$$$$;$");
        (void)newXSproto_portable("Slurm::get_select_nodeinfo", XS_Slurm_get_select_nodeinfo, file, "$$$$$");
        (void)newXSproto_portable("Slurm::load_partitions", XS_Slurm_load_partitions, file, "$;$$");
        (void)newXSproto_portable("Slurm::print_partition_info_msg", XS_Slurm_print_partition_info_msg, file, "$$$;$");
        (void)newXSproto_portable("Slurm::print_partition_info", XS_Slurm_print_partition_info, file, "$$$;$");
        (void)newXSproto_portable("Slurm::sprint_partition_info", XS_Slurm_sprint_partition_info, file, "$$;$");
        (void)newXSproto_portable("Slurm::create_partition", XS_Slurm_create_partition, file, "$$");
        (void)newXSproto_portable("Slurm::update_partition", XS_Slurm_update_partition, file, "$$");
        (void)newXSproto_portable("Slurm::delete_partition", XS_Slurm_delete_partition, file, "$$");
        (void)newXSproto_portable("Slurm::load_reservations", XS_Slurm_load_reservations, file, "$;$");
        (void)newXSproto_portable("Slurm::create_reservation", XS_Slurm_create_reservation, file, "$$");
        (void)newXSproto_portable("Slurm::update_reservation", XS_Slurm_update_reservation, file, "$$");
        (void)newXSproto_portable("Slurm::delete_reservation", XS_Slurm_delete_reservation, file, "$$");
        (void)newXSproto_portable("Slurm::print_reservation_info_msg", XS_Slurm_print_reservation_info_msg, file, "$$$;$");
        (void)newXSproto_portable("Slurm::print_reservation_info", XS_Slurm_print_reservation_info, file, "$$$;$");
        (void)newXSproto_portable("Slurm::sprint_reservation_info", XS_Slurm_sprint_reservation_info, file, "$$;$");
        (void)newXSproto_portable("Slurm::ping", XS_Slurm_ping, file, "$;$");
        (void)newXSproto_portable("Slurm::reconfigure", XS_Slurm_reconfigure, file, "$");
        (void)newXSproto_portable("Slurm::shutdown", XS_Slurm_shutdown, file, "$;$");
        (void)newXSproto_portable("Slurm::takeover", XS_Slurm_takeover, file, "$;$");
        (void)newXSproto_portable("Slurm::set_debug_level", XS_Slurm_set_debug_level, file, "$$");
        (void)newXSproto_portable("Slurm::set_schedlog_level", XS_Slurm_set_schedlog_level, file, "$$");
        (void)newXSproto_portable("Slurm::suspend", XS_Slurm_suspend, file, "$$");
        (void)newXSproto_portable("Slurm::resume", XS_Slurm_resume, file, "$$");
        (void)newXSproto_portable("Slurm::requeue", XS_Slurm_requeue, file, "$$$");
        (void)newXSproto_portable("Slurm::set_trigger", XS_Slurm_set_trigger, file, "$$");
        (void)newXSproto_portable("Slurm::clear_trigger", XS_Slurm_clear_trigger, file, "$$");
        (void)newXSproto_portable("Slurm::get_triggers", XS_Slurm_get_triggers, file, "$");
        (void)newXSproto_portable("Slurm::pull_trigger", XS_Slurm_pull_trigger, file, "$$");
        (void)newXSproto_portable("Slurm::Hostlist::create", XS_Slurm__Hostlist_create, file, "$");
        (void)newXSproto_portable("Slurm::Hostlist::count", XS_Slurm__Hostlist_count, file, "$");
        (void)newXSproto_portable("Slurm::Hostlist::find", XS_Slurm__Hostlist_find, file, "$$");
        (void)newXSproto_portable("Slurm::Hostlist::push", XS_Slurm__Hostlist_push, file, "$$");
        (void)newXSproto_portable("Slurm::Hostlist::push_host", XS_Slurm__Hostlist_push_host, file, "$$");
        (void)newXSproto_portable("Slurm::Hostlist::ranged_string", XS_Slurm__Hostlist_ranged_string, file, "$");
        (void)newXSproto_portable("Slurm::Hostlist::shift", XS_Slurm__Hostlist_shift, file, ";$");
        (void)newXSproto_portable("Slurm::Hostlist::uniq", XS_Slurm__Hostlist_uniq, file, "$");
        (void)newXSproto_portable("Slurm::Hostlist::DESTROY", XS_Slurm__Hostlist_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::List::count", XS_Slurm__List_count, file, "$");
        (void)newXSproto_portable("Slurm::List::is_empty", XS_Slurm__List_is_empty, file, "$");
        (void)newXSproto_portable("Slurm::List::DESTROY", XS_Slurm__List_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::ListIterator::create", XS_Slurm__ListIterator_create, file, "$");
        (void)newXSproto_portable("Slurm::ListIterator::reset", XS_Slurm__ListIterator_reset, file, "$");
        (void)newXSproto_portable("Slurm::ListIterator::DESTROY", XS_Slurm__ListIterator_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::alloc", XS_Slurm__Bitstr_alloc, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::copy", XS_Slurm__Bitstr_copy, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::test", XS_Slurm__Bitstr_test, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::set", XS_Slurm__Bitstr_set, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::clear", XS_Slurm__Bitstr_clear, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::nset", XS_Slurm__Bitstr_nset, file, "$$$");
        (void)newXSproto_portable("Slurm::Bitstr::nclear", XS_Slurm__Bitstr_nclear, file, "$$$");
        (void)newXSproto_portable("Slurm::Bitstr::ffc", XS_Slurm__Bitstr_ffc, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::ffs", XS_Slurm__Bitstr_ffs, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::fls", XS_Slurm__Bitstr_fls, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::nffc", XS_Slurm__Bitstr_nffc, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::nffs", XS_Slurm__Bitstr_nffs, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::noc", XS_Slurm__Bitstr_noc, file, "$$$");
        (void)newXSproto_portable("Slurm::Bitstr::size", XS_Slurm__Bitstr_size, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::and", XS_Slurm__Bitstr_and, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::not", XS_Slurm__Bitstr_not, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::or", XS_Slurm__Bitstr_or, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::copybits", XS_Slurm__Bitstr_copybits, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::set_count", XS_Slurm__Bitstr_set_count, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::set_count_range", XS_Slurm__Bitstr_set_count_range, file, "$$$");
        (void)newXSproto_portable("Slurm::Bitstr::clear_count", XS_Slurm__Bitstr_clear_count, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::nset_max_count", XS_Slurm__Bitstr_nset_max_count, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::rotate_copy", XS_Slurm__Bitstr_rotate_copy, file, "$$$");
        (void)newXSproto_portable("Slurm::Bitstr::rotate", XS_Slurm__Bitstr_rotate, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::fmt", XS_Slurm__Bitstr_fmt, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::unfmt", XS_Slurm__Bitstr_unfmt, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::fmt2int", XS_Slurm__Bitstr_fmt2int, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::fmt_hexmask", XS_Slurm__Bitstr_fmt_hexmask, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::unfmt_hexmask", XS_Slurm__Bitstr_unfmt_hexmask, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::fill_gaps", XS_Slurm__Bitstr_fill_gaps, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::super_set", XS_Slurm__Bitstr_super_set, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::overlap", XS_Slurm__Bitstr_overlap, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::equal", XS_Slurm__Bitstr_equal, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::pick_cnt", XS_Slurm__Bitstr_pick_cnt, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::get_bit_num", XS_Slurm__Bitstr_get_bit_num, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::DESTROY", XS_Slurm__Bitstr_DESTROY, file, "$");

    /* Initialisation Section */

#line 52 "Slurm.xs"
{
	slurm_init(NULL);
}

#line 6865 "Slurm.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

#ifdef __cplusplus
}
#endif
