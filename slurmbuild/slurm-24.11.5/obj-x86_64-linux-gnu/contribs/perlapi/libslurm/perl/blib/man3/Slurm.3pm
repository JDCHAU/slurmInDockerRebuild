.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Slurm 3pm"
.TH Slurm 3pm 2024-07-05 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Slurm \- Perl API for libslurm
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use Slurm;
\&
\&    my $slurm = Slurm::new();
\&    $nodes = $slurm\->load_node();
\&    unless($nodes) {
\&        die "failed to load node info: " . $slurm\->strerror();
\&    }
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
The Slurm class provides Perl interface of the Slurm API functions in \f(CW\*(C`<slurm/slurm.h>\*(C'\fR, with some extra frequently used functions exported by libslurm.
.SS METHODS
.IX Subsection "METHODS"
To use the API, first create a Slurm object:
.PP
.Vb 1
\&    $slurm = Slurm::new($conf);
.Ve
.PP
Then call the desired functions:
.PP
.Vb 1
\&    $resp = $slurm\->load_jobs();
.Ve
.PP
In the following "METHODS" section, if a parameter is omitted, it will be listed as "param=val" , where "val" is the default value of the parameter.
.SS "DATA STRUCTURES"
.IX Subsection "DATA STRUCTURES"
Typically, C structures are converted to (maybe blessed) Perl hash references, with field names as hash keys. Arrays in C are converted to arrays in Perl. For example, there is a structure \f(CW\*(C`job_info_msg_t\*(C'\fR:
.PP
.Vb 5
\&    typedef struct job_info_msg {
\&        time_t last_update;     /* time of latest info */
\&        uint32_t record_count;  /* number of records */
\&        job_info_t *job_array;  /* the job records */
\&    } job_info_msg_t;
.Ve
.PP
This will be converted to a hash reference with the following structure:
.PP
.Vb 7
\&    {
\&        last_update => 1285847672,
\&        job_array => [ {account => \*(Aqtest\*(Aq, alloc_node => \*(Aqln0\*(Aq, alloc_sid => 1234, ...},
\&                       {account => \*(Aqdebug\*(Aq, alloc_node => \*(Aqln2\*(Aq, alloc_sid => 5678, ...},
\&                       ...
\&                     ]
\&    }
.Ve
.PP
Note the missing of the \f(CW\*(C`record_count\*(C'\fR field in the hash. It can be derived from the number of elements in array \f(CW\*(C`job_array\*(C'\fR.
.PP
To pass parameters to the API functions, use the corresponding hash references, for example:
.PP
.Vb 1
\&    $rc = $slurm\->update_node({node_names => \*(Aqnode[0\-7]\*(Aq, node_state => NODE_STATE_DRAIN});
.Ve
.PP
Please see \f(CW\*(C`<slurm/slurm.h>\*(C'\fR for the definition of the structures.
.SS CONSTANTS
.IX Subsection "CONSTANTS"
The enumerations and macro definitions are available in the Slurm package. If ':constant' is given when using the Slurm package, the constants will be exported to the calling package.
.PP
Please see Slurm::Constant for the available constants.
.SH METHODS
.IX Header "METHODS"
.SS CONSTRUCTOR/DESTRUCTOR
.IX Subsection "CONSTRUCTOR/DESTRUCTOR"
\fR\f(CI$slurm\fR\fI = Slurm::new($conf_file=undef);\fR
.IX Subsection "$slurm = Slurm::new($conf_file=undef);"
.PP
Create a Slurm object. For now the object is just a hash reference with no members.
.IP \(bu 2
IN \f(CW$conf_file:\fR the Slurm configuration file. If omitted, the default Slurm configuration file will be used (file specified by environment variable SLURM_CONF or the file slurm.conf under directory specified in compile time).
.IP \(bu 2
RET: blessed opaque Slurm object. On error \f(CW\*(C`undef\*(C'\fR is returned.
.SS "ERROR INFORMATION FUNCTIONS"
.IX Subsection "ERROR INFORMATION FUNCTIONS"
\fR\f(CI$errno\fR\fI = \fR\f(CI$slurm\fR\fI\->\fR\f(BIget_errno()\fR\fI;\fR
.IX Subsection "$errno = $slurm->get_errno();"
.PP
Get the error number associated with last operation.
.IP \(bu 2
RET: error number associated with last operation.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->strerror($errno=0)\fR
.IX Subsection "$str = $slurm->strerror($errno=0)"
.PP
Get the string describing the specified error number.
.IP \(bu 2
IN \f(CW$errno:\fR error number. If omitted or 0, the error number returned by \f(CW\*(C`$slurm\-\*(C'\fR\fBget_errno()\fR> will be used.
.IP \(bu 2
RET: error string.
.SS "ENTITY STATE/REASON/FLAG/TYPE STRING FUNCTIONS"
.IX Subsection "ENTITY STATE/REASON/FLAG/TYPE STRING FUNCTIONS"
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->preempt_mode_string($mode_num);\fR
.IX Subsection "$str = $slurm->preempt_mode_string($mode_num);"
.PP
Get the string describing the specified preemt mode number.
.IP \(bu 2
IN \f(CW$mode_num:\fR preempt mode number.
.IP \(bu 2
RET: preempt mode string.
.PP
\fR\f(CI$num\fR\fI = \fR\f(CI$slurm\fR\fI\->preempt_mode_num($mode_str);\fR
.IX Subsection "$num = $slurm->preempt_mode_num($mode_str);"
.PP
Get the preempt mode number of the specified preempt mode string.
.IP \(bu 2
IN \f(CW$mode_str:\fR preempt mode string.
.IP \(bu 2
RET: preempt mode number.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->job_reason_string($num);\fR
.IX Subsection "$str = $slurm->job_reason_string($num);"
.PP
Get the string representation of the specified job state reason number.
.IP \(bu 2
IN \f(CW$num:\fR job reason number.
.IP \(bu 2
RET: job reason string.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->job_state_string($num);\fR
.IX Subsection "$str = $slurm->job_state_string($num);"
.PP
Get the string representation of the specified job state number.
.IP \(bu 2
IN \f(CW$num:\fR job state number.
.IP \(bu 2
RET: job state string.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->job_state_string_compact($num);\fR
.IX Subsection "$str = $slurm->job_state_string_compact($num);"
.PP
Get the compact string representation of the specified job state number.
.IP \(bu 2
IN \f(CW$num:\fR job state number.
.IP \(bu 2
RET: compact job state string.
.PP
\fR\f(CI$num\fR\fI = \fR\f(CI$slurm\fR\fI\->job_state_num($str);\fR
.IX Subsection "$num = $slurm->job_state_num($str);"
.PP
Get the job state number of the specified (compact) job state string.
.IP \(bu 2
IN \f(CW$str:\fR job state string.
.IP \(bu 2
RET: job state number.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->reservation_flags_string($flags);\fR
.IX Subsection "$str = $slurm->reservation_flags_string($flags);"
.PP
Get the string representation of the specified reservation flags.
.IP \(bu 2
IN \f(CW$num:\fR reservation flags number.
.IP \(bu 2
RET: reservation flags string.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->node_state_string($num);\fR
.IX Subsection "$str = $slurm->node_state_string($num);"
.PP
Get the string representation of the specified node state number.
.IP \(bu 2
IN \f(CW$num:\fR node state number.
.IP \(bu 2
RET: node state string.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->node_state_string_compact($num);\fR
.IX Subsection "$str = $slurm->node_state_string_compact($num);"
.PP
Get the compact string representation of the specified node state number.
.IP \(bu 2
IN \f(CW$num:\fR node state number.
.IP \(bu 2
RET: compact node state string.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->private_data_string($num);\fR
.IX Subsection "$str = $slurm->private_data_string($num);"
.PP
Get the string representation of the specified private data type.
.IP \(bu 2
IN \f(CW$num:\fR private data type number.
.IP \(bu 2
RET: private data type string.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->accounting_enforce_string($num);\fR
.IX Subsection "$str = $slurm->accounting_enforce_string($num);"
.PP
Get the string representation of the specified accounting enforce type.
.IP \(bu 2
IN \f(CW$num:\fR accounting enforce type number.
.IP \(bu 2
RET: accounting enforce type string.
.SS "RESOURCE ALLOCATION FUNCTIONS"
.IX Subsection "RESOURCE ALLOCATION FUNCTIONS"
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->allocate_resources($job_desc);\fR
.IX Subsection "$resp = $slurm->allocate_resources($job_desc);"
.PP
Allocate resources for a job request. If the requested resources are not immediately available, the slurmctld will send the job_alloc_resp_msg to the specified node and port.
.IP \(bu 2
IN \f(CW$job_desc:\fR description of resource allocation request, with structure of \f(CW\*(C`job_desc_msg_t\*(C'\fR.
.IP \(bu 2
RET: response to request, with structure of \f(CW\*(C`resource_allocation_response_msg_t\*(C'\fR.  This only represents a job allocation if resources are immediately available.  Otherwise it just contains the job id of the enqueued job request. On failure \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->allocate_resources_blocking($job_desc, \fR\f(CI$timeout\fR\fI=0, \fR\f(CI$pending_callbacks\fR\fI=undef);\fR
.IX Subsection "$resp = $slurm->allocate_resources_blocking($job_desc, $timeout=0, $pending_callbacks=undef);"
.PP
Allocate resources for a job request.  This call will block until the allocation is granted, or the specified timeout limit is reached.
.IP \(bu 2
IN \f(CW$job_desc:\fR description of resource allocation request, with structure of \f(CW\*(C`job_desc_msg_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$timeout:\fR amount of time, in seconds, to wait for a response before giving up. A timeout of zero will wait indefinitely.
.IP \(bu 2
IN \f(CW$pending_callbacks:\fR If the allocation cannot be granted immediately, the controller will put the job in the PENDING state.  If
pending callback is given, it will be called with the job id of the pending job as the sole parameter.
.IP \(bu 2
RET: allcation response, with structure of \f(CW\*(C`resource_allocation_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned, with errno set.
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->allocatiion_lookup($job_id);\fR
.IX Subsection "$resp = $slurm->allocatiion_lookup($job_id);"
.PP
Retrieve info for an existing resource allocation.
.IP \(bu 2
IN \f(CW$job_id:\fR job allocation identifier.
.IP \(bu 2
RET: job allocation info, with structure of \f(CW\*(C`resource_allocation_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->read_hostfile($filename, \fR\f(CI$n\fR\fI);\fR
.IX Subsection "$str = $slurm->read_hostfile($filename, $n);"
.PP
Read a specified Slurm hostfile. The file must contain a list of Slurm NodeNames, one per line.
.IP \(bu 2
IN \f(CW$filename:\fR name of Slurm hostlist file to be read.
.IP \(bu 2
IN \f(CW$n:\fR number of NodeNames required.
.IP \(bu 2
RET: a string representing the hostlist. Returns NULL if there are fewer than \f(CW$n\fR hostnames in the file, or if an error occurs.
.PP
\fR\f(CI$msg_thr\fR\fI = \fR\f(CI$slurm\fR\fI\->allocation_msg_thr_create($port, \fR\f(CI$callbacks\fR\fI);\fR
.IX Subsection "$msg_thr = $slurm->allocation_msg_thr_create($port, $callbacks);"
.PP
Startup a message handler talking with the controller dealing with messages from the controller during an allocation.
.IP \(bu 2
OUT \f(CW$port:\fR port we are listening for messages on from the controller.
.IP \(bu 2
IN \f(CW$callbacks:\fR callbacks for different types of messages, with structure of \f(CW\*(C`slurm_allocation_callbacks_t\*(C'\fR.
.IP \(bu 2
RET: opaque object of \f(CW\*(C`allocation_msg_thread_t *\*(C'\fR,  or NULL on failure.
.PP
\fR\f(CI$slurm\fR\fI\->allocation_msg_thr_destroy($msg_thr);\fR
.IX Subsection "$slurm->allocation_msg_thr_destroy($msg_thr);"
.PP
Shutdown the message handler talking with the controller dealing with messages from the controller during an allocation.
.IP \(bu 2
IN \f(CW$msg_thr:\fR opaque object of \f(CW\*(C`allocation_msg_thread_t\*(C'\fR pointer.
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->submit_batch_job($job_desc_msg);\fR
.IX Subsection "$resp = $slurm->submit_batch_job($job_desc_msg);"
.PP
Issue RPC to submit a job for later execution.
.IP \(bu 2
IN \f(CW$job_desc_msg:\fR description of batch job request, with structure of \f(CW\*(C`job_desc_msg_t\*(C'\fR.
.IP \(bu 2
RET: SLURM_SUCCESS on success, otherwise return SLURM_ERROR with errno set.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->job_will_run($job_desc_msg);\fR
.IX Subsection "$rc = $slurm->job_will_run($job_desc_msg);"
.PP
Determine if a job would execute immediately if submitted now.
.IP \(bu 2
IN \f(CW$job_desc_msg:\fR description of resource allocation request, with structure of \f(CW\*(C`job_desc_msg_t\*(C'\fR.
.IP \(bu 2
RET: SLURM_SUCCESS on success, otherwise return SLURM_ERROR with errno set.
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->sbcast_lookup($job_id);\fR
.IX Subsection "$resp = $slurm->sbcast_lookup($job_id);"
.PP
Retrieve info for an existing resource allocation including a credential needed for sbcast.
.IP \(bu 2
IN \f(CW$jobid:\fR job allocation identifier.
.IP \(bu 2
RET: job allocation information includeing a credential for sbcast, with structure of \f(CW\*(C`job_sbcast_cred_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.SS "JOB/STEP SIGNALING FUNCTIONS"
.IX Subsection "JOB/STEP SIGNALING FUNCTIONS"
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->kill_job($job_id, \fR\f(CI$signal\fR\fI, \fR\f(CI$batch_flag\fR\fI=0);\fR
.IX Subsection "$rc = $slurm->kill_job($job_id, $signal, $batch_flag=0);"
.PP
Send the specified signal to all steps of an existing job.
.IP \(bu 2
IN \f(CW$job_id:\fR the job's id.
.IP \(bu 2
IN \f(CW$signal:\fR signal number.
.IP \(bu 2
IN \f(CW$batch_flag:\fR 1 to signal batch shell only, otherwise 0.
.IP \(bu 2
RET: SLURM_SUCCESS on success, otherwise return SLURM_ERROR with errno set.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->kill_job_step($job_id, \fR\f(CI$step_id\fR\fI, \fR\f(CI$signal\fR\fI);\fR
.IX Subsection "$rc = $slurm->kill_job_step($job_id, $step_id, $signal);"
.PP
Send the specified signal to an existing job step.
.IP \(bu 2
IN \f(CW$job_id:\fR the job's id.
.IP \(bu 2
IN \f(CW$step_id:\fR the job step's id.
.IP \(bu 2
IN \f(CW$signal:\fR signal number.
.IP \(bu 2
RET: SLURM_SUCCESS on success, otherwise return SLURM_ERROR with errno set.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->signal_job($job_id, \fR\f(CI$signal\fR\fI);\fR
.IX Subsection "$rc = $slurm->signal_job($job_id, $signal);"
.PP
Send the specified signal to all steps of an existing job.
.IP \(bu 2
IN \f(CW$job_id:\fR the job's id.
.IP \(bu 2
IN \f(CW$signal:\fR signal number.
.IP \(bu 2
RET: SLURM_SUCCESS on success, otherwise return SLURM_ERROR with errno set.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->signal_job_step($job_id, \fR\f(CI$step_id\fR\fI, \fR\f(CI$signal\fR\fI);\fR
.IX Subsection "$rc = $slurm->signal_job_step($job_id, $step_id, $signal);"
.PP
Send the specified signal to an existing job step.
.IP \(bu 2
IN \f(CW$job_id:\fR the job's id.
.IP \(bu 2
IN \f(CW$step_id:\fR the job step's id.
.IP \(bu 2
IN \f(CW$signal:\fR signal number.
.IP \(bu 2
RET: SLURM_SUCCESS on success, otherwise return SLURM_ERROR with errno set.
.SS "JOB/STEP COMPLETION FUNCTIONS"
.IX Subsection "JOB/STEP COMPLETION FUNCTIONS"
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->complete_job($job_id, \fR\f(CI$job_rc\fR\fI=0);\fR
.IX Subsection "$rc = $slurm->complete_job($job_id, $job_rc=0);"
.PP
Note the completion of a job and all of its steps.
.IP \(bu 2
IN \f(CW$job_id:\fR the job's id.
.IP \(bu 2
IN \f(CW$job_rc:\fR the highest exit code of any task of the job.
.IP \(bu 2
RET: SLURM_SUCCESS on success, otherwise return SLURM_ERROR with errno set.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->terminate_job_step($job_id, \fR\f(CI$step_id\fR\fI);\fR
.IX Subsection "$rc = $slurm->terminate_job_step($job_id, $step_id);"
.PP
Terminates a job step by sending a REQUEST_TERMINATE_TASKS rpc to all slurmd of a job step, and then calls \fBslurm_complete_job_step()\fR after verifying that all nodes in the job step no longer have running tasks from the job step.  (May take over 35 seconds to return.)
.IP \(bu 2
IN \f(CW$job_id:\fR the job's id.
.IP \(bu 2
IN \f(CW$step_id:\fR the job step's id \- use SLURM_BATCH_SCRIPT as the step_id to terminate a job's batch script.
.IP \(bu 2
RET: SLURM_SUCCESS on success, otherwise return SLURM_ERROR with errno set.
.SS "Slurm TASK SPAWNING FUNCTIONS"
.IX Subsection "Slurm TASK SPAWNING FUNCTIONS"
\fR\f(CI$ctx\fR\fI = \fR\f(CI$slurm\fR\fI\->step_ctx_create($params);\fR
.IX Subsection "$ctx = $slurm->step_ctx_create($params);"
.PP
Create a job step and its context.
.IP \(bu 2
IN \f(CW$params:\fR job step parameters, with structure of \f(CW\*(C`slurm_step_ctx_params_t\*(C'\fR.
.IP \(bu 2
RET: the step context. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$ctx\fR\fI = \fR\f(CI$slurm\fR\fI\->step_ctx_create_no_alloc($params);\fR
.IX Subsection "$ctx = $slurm->step_ctx_create_no_alloc($params);"
.PP
Create a job step and its context without getting an allocation.
.IP \(bu 2
IN \f(CW$params:\fR job step parameters, with structure of \f(CW\*(C`slurm_step_ctx_params_t\*(C'\fR..
.IP \(bu 2
IN \f(CW$step_id:\fR fake job step id.
.IP \(bu 2
RET: the step context. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.SS "SLURM CONTROL CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
.IX Subsection "SLURM CONTROL CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fI($major, \fR\f(CI$minor\fR\fI, \fR\f(CI$micro\fR\fI) = \fR\f(CI$slurm\fR\fI\->\fR\f(BIapi_version()\fR\fI;\fR
.IX Subsection "($major, $minor, $micro) = $slurm->api_version();"
.PP
Get the Slurm API's version number.
.IP \(bu 2
RET: a three element list of the major, minor, and micro version number.
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->load_ctl_conf($update_time=0);\fR
.IX Subsection "$resp = $slurm->load_ctl_conf($update_time=0);"
.PP
Issue RPC to get Slurm control configuration information if changed.
.IP \(bu 2
IN \f(CW$update_time:\fR time of current configuration data.
.IP \(bu 2
RET: Slurm configuration data, with structure of \f(CW\*(C`slurm_ctl_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$slurm\fR\fI\->print_ctl_conf($out, \fR\f(CI$conf\fR\fI);\fR
.IX Subsection "$slurm->print_ctl_conf($out, $conf);"
.PP
Output the contents of Slurm control configuration message as loaded using \f(CWload_ctl_conf()\fR.
.IP \(bu 2
IN \f(CW$out:\fR file to write to.
.IP \(bu 2
IN \f(CW$conf:\fR Slurm control configuration, with structure of \f(CW\*(C`slurm_conf_t\*(C'\fR.
.PP
\fR\f(CI$list\fR\fI = \fR\f(CI$slurm\fR\fI\->ctl_conf_2_key_pairs($conf);\fR
.IX Subsection "$list = $slurm->ctl_conf_2_key_pairs($conf);"
.PP
Put the Slurm configuration data into a List of opaque data type \f(CW\*(C`config_key_pair_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$conf:\fR Slurm control configuration, with structure of \f(CW\*(C`slurm_conf_t\*(C'\fR.
.IP \(bu 2
RET: List of opaque data type \f(CW\*(C`config_key_pair_t\*(C'\fR.
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->\fR\f(BIload_slurmd_status()\fR\fI;\fR
.IX Subsection "$resp = $slurm->load_slurmd_status();"
.PP
Issue RPC to get the status of slurmd daemon on this machine.
.IP \(bu 2
RET: slurmd status info, with structure of \f(CW\*(C`slurmd_status_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$slurm\fR\fI\->print_slurmd_status($out, \fR\f(CI$slurmd_status\fR\fI);\fR
.IX Subsection "$slurm->print_slurmd_status($out, $slurmd_status);"
.PP
Output the contents of slurmd status message as loaded using \f(CWload_slurmd_status()\fR.
.IP \(bu 2
IN \f(CW$out:\fR file to write to.
.IP \(bu 2
IN \f(CW$slurmd_status:\fR slurmd status info, with structure of \f(CW\*(C`slurmd_status_t\*(C'\fR.
.PP
\fR\f(CI$slurm\fR\fI\->print_key_pairs($out, \fR\f(CI$key_pairs\fR\fI, \fR\f(CI$title\fR\fI);\fR
.IX Subsection "$slurm->print_key_pairs($out, $key_pairs, $title);"
.PP
Output the contents of key_pairs which is a list of opaque data type \f(CW\*(C`config_key_pair_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$out:\fR file to write to.
.IP \(bu 2
IN \f(CW$key_pairs:\fR List containing key pairs to be printed.
.IP \(bu 2
IN \f(CW$title:\fR title of key pair list.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->update_step($step_msg);\fR
.IX Subsection "$rc = $slurm->update_step($step_msg);"
.PP
Update the time limit of a job step.
.IP \(bu 2
IN \f(CW$step_msg:\fR step update messasge descriptor, with structure of \f(CW\*(C`step_update_request_msg_t\*(C'\fR.
.IP \(bu 2
RET: 0 or \-1 on error.
.SS "SLURM JOB RESOURCES READ/PRINT FUNCTIONS"
.IX Subsection "SLURM JOB RESOURCES READ/PRINT FUNCTIONS"
\fR\f(CI$num\fR\fI = \fR\f(CI$slurm\fR\fI\->job_cpus_allocated_on_node_id($job_res, \fR\f(CI$node_id\fR\fI);\fR
.IX Subsection "$num = $slurm->job_cpus_allocated_on_node_id($job_res, $node_id);"
.PP
Get the number of cpus allocated to a job on a node by node id.
.IP \(bu 2
IN \f(CW$job_res:\fR job resources data, with structure of \f(CW\*(C`job_resources_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$node_id:\fR zero-origin node id in allocation.
.IP \(bu 2
RET: number of CPUs allocated to job on this node or \-1 on error.
.PP
\fR\f(CI$num\fR\fI = \fR\f(CI$slurm\fR\fI\->job_cpus_allocated_on_node($job_res, \fR\f(CI$node_name\fR\fI);\fR
.IX Subsection "$num = $slurm->job_cpus_allocated_on_node($job_res, $node_name);"
.PP
Get the number of cpus allocated to a job on a node by node name.
.IP \(bu 2
IN \f(CW$job_res:\fR job resources data, with structure of \f(CW\*(C`job_resources_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$node_name:\fR name of node.
.IP \(bu 2
RET: number of CPUs allocated to job on this node or \-1 on error.
.SS "SLURM JOB CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
.IX Subsection "SLURM JOB CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fR\f(CI$time\fR\fI = \fR\f(CI$slurm\fR\fI\->get_end_time($job_id);\fR
.IX Subsection "$time = $slurm->get_end_time($job_id);"
.PP
Get the expected end time for a given slurm job.
.IP \(bu 2
IN \f(CW$jobid:\fR Slurm job id.
.IP \(bu 2
RET: scheduled end time for the job. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$secs\fR\fI = \fR\f(CI$slurm\fR\fI\->get_rem_time($job_id);\fR
.IX Subsection "$secs = $slurm->get_rem_time($job_id);"
.PP
Get the expected time remaining for a given job.
.IP \(bu 2
IN \f(CW$jobid:\fR Slurm job id.
.IP \(bu 2
RET: remaining time in seconds or \-1 on error.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->job_node_ready($job_id);\fR
.IX Subsection "$rc = $slurm->job_node_ready($job_id);"
.PP
Report if nodes are ready for job to execute now.
.IP \(bu 2
IN \f(CW$job_id:\fR Slurm job id.
.IP \(bu 2
RET:
.RS 2
.IP \(bu 2
READY_JOB_FATAL: fatal error
.IP \(bu 2
READY_JOB_ERROR: ordinary error
.IP \(bu 2
READY_NODE_STATE: node is ready
.IP \(bu 2
READY_JOB_STATE: job is ready to execute
.RE
.RS 2
.RE
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->load_job($job_id, \fR\f(CI$show_flags\fR\fI=0);\fR
.IX Subsection "$resp = $slurm->load_job($job_id, $show_flags=0);"
.PP
Issue RPC to get job information for one job ID.
.IP \(bu 2
IN \f(CW$job_id:\fR ID of job we want information about.
.IP \(bu 2
IN \f(CW$show_flags:\fR job filtering options.
.IP \(bu 2
RET: job information, with structure of \f(CW\*(C`job_info_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->load_jobs($update_time=0, \fR\f(CI$show_flags\fR\fI=0);\fR
.IX Subsection "$resp = $slurm->load_jobs($update_time=0, $show_flags=0);"
.PP
Issue RPC to get all Slurm job information if changed.
.IP \(bu 2
IN \f(CW$update_time:\fR time of current job information data.
.IP \(bu 2
IN \f(CW$show_flags:\fR job filtering options.
.IP \(bu 2
RET: job information, with structure of \f(CW\*(C`job_info_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->notify_job($job_id, \fR\f(CI$message\fR\fI);\fR
.IX Subsection "$rc = $slurm->notify_job($job_id, $message);"
.PP
Send message to the job's stdout, usable only by user root.
.IP \(bu 2
IN \f(CW$job_id:\fR Slurm job id or 0 for all jobs.
.IP \(bu 2
IN \f(CW$message:\fR arbitrary message.
.IP \(bu 2
RET: 0 or \-1 on error.
.PP
\fR\f(CI$job_id\fR\fI = \fR\f(CI$slurm\fR\fI\->pid2jobid($job_pid);\fR
.IX Subsection "$job_id = $slurm->pid2jobid($job_pid);"
.PP
Issue RPC to get the Slurm job ID of a given process ID on this machine.
.IP \(bu 2
IN \f(CW$job_pid:\fR process ID of interest on this machine.
.IP \(bu 2
RET: corresponding job ID. On failure \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fR\f(CI$slurm\fR\fI\->print_job_info($out, \fR\f(CI$job_info\fR\fI, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$slurm->print_job_info($out, $job_info, $one_liner=0);"
.PP
Output information about a specific Slurm job based upon message as loaded using \f(CWload_jobs()\fR.
.IP \(bu 2
IN \f(CW$out:\fR file to write to.
.IP \(bu 2
IN \f(CW$job_info:\fR an individual job information record, with structure of \f(CW\*(C`job_info_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if true.
.PP
\fR\f(CI$slurm\fR\fI\->print_job_info_msg($out, \fR\f(CI$job_info_msg\fR\fI, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$slurm->print_job_info_msg($out, $job_info_msg, $one_liner=0);"
.PP
Output information about all Slurm jobs based upon message as loaded using \f(CWload_jobs()\fR.
.IP \(bu 2
IN \f(CW$out:\fR file to write to.
.IP \(bu 2
IN \f(CW$job_info_msg:\fR job information message, with structure of \f(CW\*(C`job_info_msg_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if true.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->sprint_job_info($job_info, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$str = $slurm->sprint_job_info($job_info, $one_liner=0);"
.PP
Output information about a specific Slurm job based upon message as loaded using \f(CWload_jobs()\fR.
.IP \(bu 2
IN \f(CW$job_info:\fR an individual job information record, with structure of \f(CW\*(C`job_info_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if true.
.IP \(bu 2
RET: string containing formatted output.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->update_job($job_info);\fR
.IX Subsection "$rc = $slurm->update_job($job_info);"
.PP
Issue RPC to a job's configuration per request only usable by user root or (for some parameters) the job's owner.
.IP \(bu 2
IN \f(CW$job_info:\fR description of job updates, with structure of \f(CW\*(C`job_desc_msg_t\*(C'\fR.
.IP \(bu 2
RET: SLURM_SUCCESS on success, otherwise return SLURM_ERROR with errno set.
.SS "SLURM JOB STEP CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
.IX Subsection "SLURM JOB STEP CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->get_job_steps($update_time=0, \fR\f(CI$job_id\fR\fI=NO_VAL, \fR\f(CI$step_id\fR\fI=NO_VAL, \fR\f(CI$show_flags\fR\fI=0);\fR
.IX Subsection "$resp = $slurm->get_job_steps($update_time=0, $job_id=NO_VAL, $step_id=NO_VAL, $show_flags=0);"
.PP
Issue RPC to get specific slurm job step configuration information if changed since update_time.
.IP \(bu 2
IN \f(CW$update_time:\fR time of current configuration data.
.IP \(bu 2
IN \f(CW$job_id:\fR get information for specific job id, NO_VAL for all jobs.
.IP \(bu 2
IN \f(CW$step_id:\fR get information for specific job step id, NO_VAL for all job steps.
.IP \(bu 2
IN \f(CW$show_flags:\fR job step filtering options.
.IP \(bu 2
RET: job step information, with structure of \f(CW\*(C`job_step_info_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$slurm\fR\fI\->print_job_step_info_msg($out, \fR\f(CI$step_info_msg\fR\fI, \fR\f(CI$one_liner\fR\fI);\fR
.IX Subsection "$slurm->print_job_step_info_msg($out, $step_info_msg, $one_liner);"
.PP
Output information about all Slurm job steps based upon message as loaded using \f(CWget_job_steps()\fR.
.IP \(bu 2
IN \f(CW$out:\fR file to write to.
.IP \(bu 2
IN \f(CW$step_info_msg:\fR job step information message, with structure of \f(CW\*(C`job_step_info_response_msg_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if true.
.PP
\fR\f(CI$slurm\fR\fI\->print_job_step_info($out, \fR\f(CI$step_info\fR\fI, \fR\f(CI$one_liner\fR\fI);\fR
.IX Subsection "$slurm->print_job_step_info($out, $step_info, $one_liner);"
.PP
Output information about a specific Slurm job step based upon message as loaded using \f(CWget_job_steps()\fR.
.IP \(bu 2
IN \f(CW$out:\fR file to write to.
.IP \(bu 2
IN \f(CW$step_info:\fR job step information, with structure of \f(CW\*(C`job_step_info_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if true.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->sprint_job_step_info($step_info, \fR\f(CI$one_liner\fR\fI);\fR
.IX Subsection "$str = $slurm->sprint_job_step_info($step_info, $one_liner);"
.PP
Output information about a specific Slurm job step based upon message as loaded using \f(CWget_job_steps()\fR.
.IP \(bu 2
IN \f(CW$step_info:\fR job step information, with structure of \f(CW\*(C`job_step_info_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if true.
.IP \(bu 2
RET: string containing formatted output.
.PP
\fR\f(CI$layout\fR\fI = \fR\f(CI$slurm\fR\fI\->job_step_layout_get($job_id, \fR\f(CI$step_id\fR\fI);\fR
.IX Subsection "$layout = $slurm->job_step_layout_get($job_id, $step_id);"
.PP
Get the layout structure for a particular job step.
.IP \(bu 2
IN \f(CW$job_id:\fR Slurm job ID.
.IP \(bu 2
IN \f(CW$step_id:\fR Slurm step ID.
.IP \(bu 2
RET: layout of the job step, with structure of \f(CW\*(C`slurm_step_layout_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->job_step_stat($job_id, \fR\f(CI$step_id\fR\fI, \fR\f(CI$nodelist\fR\fI=undef);\fR
.IX Subsection "$resp = $slurm->job_step_stat($job_id, $step_id, $nodelist=undef);"
.PP
Get status of a current step.
.IP \(bu 2
IN \f(CW$job_id\fR : Slurm job ID.
.IP \(bu 2
IN \f(CW$step_id:\fR Slurm step ID.
.IP \(bu 2
IN \f(CW$nodelist:\fR nodes to check status of step. If omitted, all nodes in step are used.
.IP \(bu 2
RET: response of step status, with structure of \f(CW\*(C`job_step_stat_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->job_step_get_pids($job_id, \fR\f(CI$step_id\fR\fI, \fR\f(CI$nodelist\fR\fI);\fR
.IX Subsection "$resp = $slurm->job_step_get_pids($job_id, $step_id, $nodelist);"
.PP
Get the complete list of pids for a given job step.
.IP \(bu 2
IN \f(CW$job_id:\fR Slurm job ID.
.IP \(bu 2
IN \f(CW$step_id:\fR Slurm step ID.
.IP \(bu 2
IN \f(CW$nodelist:\fR nodes to check pids of step. If omitted, all nodes in step are used.
.IP \(bu 2
RET: response of pids information, with structure of \f(CW\*(C`job_step_pids_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned.
.SS "SLURM NODE CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
.IX Subsection "SLURM NODE CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->load_node($update_time=0, \fR\f(CI$show_flags\fR\fI=0);\fR
.IX Subsection "$resp = $slurm->load_node($update_time=0, $show_flags=0);"
.PP
Issue RPC to get all node configuration information if changed.
.IP \(bu 2
IN \f(CW$update_time:\fR time of current configuration data.
.IP \(bu 2
IN \f(CW$show_flags:\fR node filtering options.
.IP \(bu 2
RET: response hash reference with structure of \f(CW\*(C`node_info_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$slurm\fR\fI\->print_node_info_msg($out, \fR\f(CI$node_info_msg\fR\fI, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$slurm->print_node_info_msg($out, $node_info_msg, $one_liner=0);"
.PP
Output information about all Slurm nodes based upon message as loaded using \f(CWload_node()\fR.
.IP \(bu 2
IN \f(CW$out:\fR FILE handle to write to.
.IP \(bu 2
IN \f(CW$node_info_msg:\fR node information message to print, with structure of \f(CW\*(C`node_info_msg_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR if true, each node info will be printed as a single line.
.PP
\fR\f(CI$slurm\fR\fI\->print_node_table($out, \fR\f(CI$node_info\fR\fI, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$slurm->print_node_table($out, $node_info, $one_liner=0);"
.PP
Output information about a specific Slurm node based upon message as loaded using \f(CWload_node()\fR.
.IP \(bu 2
IN \f(CW$out:\fR FILE handle to write to.
.IP \(bu 2
IN \f(CW$node_info:\fR an individual node information record with structure of \f(CW\*(C`node_info_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR whether to print as a single line.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->sprint_node_table($node_info, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$str = $slurm->sprint_node_table($node_info, $one_liner=0);"
.PP
Output information about a specific Slurm node based upon message as loaded using \f(CW\*(C`load_node\*(C'\fR.
.IP \(bu 2
IN \f(CW$node_info:\fR an individual node information record with structure of \f(CW\*(C`node_info_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR whether to print as a single line.
.IP \(bu 2
RET: string containing formatted output on success, \f(CW\*(C`undef\*(C'\fR on failure.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->update_node($node_info);\fR
.IX Subsection "$rc = $slurm->update_node($node_info);"
.PP
Issue RPC to modify a node's configuration per request, only usable by user root.
.IP \(bu 2
IN \f(CW$node_info:\fR description of node updates, with structure of \f(CW\*(C`update_node_msg_t\*(C'\fR.
.IP \(bu 2
RET: 0 on success, \-1 on failure with errno set.
.SS "SLURM SWITCH TOPOLOGY CONFIGURATION READ/PRINT FUNCTIONS"
.IX Subsection "SLURM SWITCH TOPOLOGY CONFIGURATION READ/PRINT FUNCTIONS"
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->\fR\f(BIload_topo()\fR\fI;\fR
.IX Subsection "$resp = $slurm->load_topo();"
.PP
Issue RPC to get all switch topology configuration information.
.IP \(bu 2
RET: response hash reference with structure of \f(CW\*(C`topo_info_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$slurm\fR\fI\->print_topo_info_msg($out, \fR\f(CI$topo_info_msg\fR\fI, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$slurm->print_topo_info_msg($out, $topo_info_msg, $one_liner=0);"
.PP
Output information about all switch topology configuration information based upon message as loaded using \f(CWload_topo()\fR.
.IP \(bu 2
IN \f(CW$out:\fR FILE handle to write to.
.IP \(bu 2
IN \f(CW$topo_info_msg:\fR swith topology information message, with structure of \f(CW\*(C`topo_info_response_msg_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if not zero.
.PP
\fR\f(CI$slurm\fR\fI\->print_topo_record($out, \fR\f(CI$topo_info\fR\fI, \fR\f(CI$one_liner\fR\fI);\fR
.IX Subsection "$slurm->print_topo_record($out, $topo_info, $one_liner);"
.PP
Output information about a specific Slurm topology record based upon message as loaded using \f(CWload_topo()\fR.
.IP \(bu 2
IN \f(CW$out:\fR FILE handle to write to.
.IP \(bu 2
IN \f(CW$topo_info:\fR an individual switch information record, with structure of \f(CW\*(C`topo_info_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if not zero.
.SS "SLURM SELECT READ/PRINT/UPDATE FUNCTIONS"
.IX Subsection "SLURM SELECT READ/PRINT/UPDATE FUNCTIONS"
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->get_select_nodeinfo($nodeinfo, \fR\f(CI$data_type\fR\fI, \fR\f(CI$state\fR\fI, \fR\f(CI$data\fR\fI);\fR
.IX Subsection "$rc = $slurm->get_select_nodeinfo($nodeinfo, $data_type, $state, $data);"
.PP
Get data from a select node credential.
.IP \(bu 2
IN \f(CW$nodeinfo:\fR select node credential to get data from.
.IP \(bu 2
IN \f(CW$data_type:\fR type of data to get.
.RS 2
.IP \(bu 2
TODO: enumerate data type and returned value.
.RE
.RS 2
.RE
.IP \(bu 2
IN \f(CW$state:\fR state of node query.
.IP \(bu 2
OUT \f(CW$data:\fR the data got.
.SS "SLURM PARTITION CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
.IX Subsection "SLURM PARTITION CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->load_partitions($update_time=0, \fR\f(CI$show_flags\fR\fI=0);\fR
.IX Subsection "$resp = $slurm->load_partitions($update_time=0, $show_flags=0);"
.PP
Issue RPC to get all Slurm partition configuration information if changed.
.IP \(bu 2
IN \f(CW$update_time:\fR time of current configuration data.
.IP \(bu 2
IN \f(CW$show_flags:\fR partitions filtering options.
.IP \(bu 2
RET: response hash reference with structure of \f(CW\*(C`partition_info_msg_t\*(C'\fR.
.PP
\fR\f(CI$slurm\fR\fI\->print_partition_info_msg($out, \fR\f(CI$part_info_msg\fR\fI, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$slurm->print_partition_info_msg($out, $part_info_msg, $one_liner=0);"
.PP
Output information about all Slurm partitions based upon message as loaded using \f(CWload_partitions()\fR.
.IP \(bu 2
IN \f(CW$out:\fR FILE handle to write to.
.IP \(bu 2
IN \f(CW$part_info_msg:\fR partitions information message, with structure of \f(CW\*(C`partition_info_msg_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if true.
.PP
\fR\f(CI$slurm\fR\fI\->print_partition_info($out, \fR\f(CI$part_info\fR\fI, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$slurm->print_partition_info($out, $part_info, $one_liner=0);"
.PP
Output information about a specific Slurm partition based upon message as loaded using \f(CWload_partitions()\fR.
.IP \(bu 2
IN \f(CW$out:\fR FILE handle to write to.
.IP \(bu 2
IN \f(CW$part_info:\fR an individual partition information record, with structure of \f(CW\*(C`partition_info_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single ine if true.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->sprint_partition_info($part_info, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$str = $slurm->sprint_partition_info($part_info, $one_liner=0);"
.PP
Output information about a specific Slurm partition based upon message as loaded using \f(CWload_reservations()\fR.
.IP \(bu 2
IN \f(CW$part_info:\fR an individual partition information record, with structure of \f(CW\*(C`partition_info_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if true.
.IP \(bu 2
RET: string containing formatted output. On failure \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->create_partition($part_info);\fR
.IX Subsection "$rc = $slurm->create_partition($part_info);"
.PP
Create a new partition, only usable by user root.
.IP \(bu 2
IN \f(CW$part_info:\fR description of partition configuration with structure of \f(CW\*(C`update_part_msg_t\*(C'\fR.
.IP \(bu 2
RET: 0 on success, \-1 on failure with errno set.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->update_partition($part_info);\fR
.IX Subsection "$rc = $slurm->update_partition($part_info);"
.PP
Issue RPC to update a partition's configuration per request, only usable by user root.
.IP \(bu 2
IN \f(CW$part_info:\fR description of partition updates with structure of \f(CW\*(C`update_part_msg_t\*(C'\fR.
.IP \(bu 2
RET: 0 on success, \-1 on failure with errno set.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->delete_partition($part_info)\fR
.IX Subsection "$rc = $slurm->delete_partition($part_info)"
.PP
Issue RPC to delete a partition, only usable by user root.
.IP \(bu 2
IN \f(CW$part_info:\fR description of partition to delete, with structure of \f(CW\*(C`delete_part_msg_t\*(C'\fR.
.IP \(bu 2
RET: 0 on success, \-1 on failure with errno set.
.SS "SLURM RESERVATION CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
.IX Subsection "SLURM RESERVATION CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fR\f(CI$name\fR\fI = \fR\f(CI$slurm\fR\fI\->create_reservation($resv_info);\fR
.IX Subsection "$name = $slurm->create_reservation($resv_info);"
.PP
Create a new reservation, only usable by user root.
.IP \(bu 2
IN \f(CW$resv_info:\fR description of reservation, with structure of \f(CW\*(C`resv_desc_msg_t\*(C'\fR.
.IP \(bu 2
RET: name of reservation created. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->update_reservation($resv_info);\fR
.IX Subsection "$rc = $slurm->update_reservation($resv_info);"
.PP
Modify an existing reservation, only usable by user root.
.IP \(bu 2
IN \f(CW$resv_info:\fR description of reservation, with structure of \f(CW\*(C`resv_desc_msg_t\*(C'\fR.
.IP \(bu 2
RET: error code.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->delete_reservation($resv_info);\fR
.IX Subsection "$rc = $slurm->delete_reservation($resv_info);"
.PP
Issue RPC to delete a reservation, only usable by user root.
.IP \(bu 2
IN \f(CW$resv_info:\fR description of reservation to delete, with structure of \f(CW\*(C`reservation_name_msg_t\*(C'\fR.
.IP \(bu 2
RET: error code
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->load_reservations($update_time=0);\fR
.IX Subsection "$resp = $slurm->load_reservations($update_time=0);"
.PP
Issue RPC to get all Slurm reservation configuration information if changed.
.IP \(bu 2
IN \f(CW$update_time:\fR time of current configuration data.
.IP \(bu 2
RET: response of reservation information, with structure of \f(CW\*(C`reserve_info_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fR\f(CI$slurm\fR\fI\->print_reservation_info_msg($out, \fR\f(CI$resv_info_msg\fR\fI, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$slurm->print_reservation_info_msg($out, $resv_info_msg, $one_liner=0);"
.PP
Output information about all Slurm reservations based upon message as loaded using \f(CWload_reservation()\fR.
.IP \(bu 2
IN \f(CW$out:\fR FILE handle to write to.
.IP \(bu 2
IN \f(CW$resv_info_msg:\fR reservation information message, with structure of \f(CW\*(C`reserve_info_msg_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if true.
.PP
\fR\f(CI$slurm\fR\fI\->print_reservation_info($out, \fR\f(CI$resv_info\fR\fI, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$slurm->print_reservation_info($out, $resv_info, $one_liner=0);"
.PP
Output information about a specific Slurm reservation based upon message as loaded using \f(CWload_reservation()\fR.
.IP \(bu 2
IN \f(CW$out:\fR FILE handle to write to.
.IP \(bu 2
IN \f(CW$resv_info:\fR an individual reservation information record, with structure of \f(CW\*(C`reserve_info_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if true.
.PP
\fR\f(CI$str\fR\fI = \fR\f(CI$slurm\fR\fI\->sprint_reservation_info($resv_info, \fR\f(CI$one_liner\fR\fI=0);\fR
.IX Subsection "$str = $slurm->sprint_reservation_info($resv_info, $one_liner=0);"
.PP
Output information about a specific Slurm reservation based upon message as loaded using \f(CWload_reservations()\fR.
.IP \(bu 2
IN \f(CW$resv_info:\fR an individual reservation information record, with structure of \f(CW\*(C`reserve_info_t\*(C'\fR.
.IP \(bu 2
IN \f(CW$one_liner:\fR print as a single line if true.
.IP \(bu 2
RET: string containing formatted output. On failure \f(CW\*(C`undef\*(C'\fR is returned.
.SS "SLURM PING/RECONFIGURE/SHUTDOWN FUNCTIONS"
.IX Subsection "SLURM PING/RECONFIGURE/SHUTDOWN FUNCTIONS"
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->ping($primary);\fR
.IX Subsection "$rc = $slurm->ping($primary);"
.PP
Issue RPC to ping Slurm controller (slurmctld).
.IP \(bu 2
IN primary: 1 for primary controller, 2 for secondary controller.
.IP \(bu 2
RET: error code.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->\fR\f(BIreconfigure()\fR\fI\fR
.IX Subsection "$rc = $slurm->reconfigure()"
.PP
Issue RPC to have Slurm controller (slurmctld) reload its configuration file.
.IP \(bu 2
RET: error code.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->shutdown($options);\fR
.IX Subsection "$rc = $slurm->shutdown($options);"
.PP
Issue RPC to have Slurm controller (slurmctld) cease operations, both the primary and backup controller are shutdown.
.IP \(bu 2
IN \f(CW$options:\fR
.RS 2
.IP \(bu 4
0: all slurm daemons are shutdown.
.IP \(bu 4
1: slurmctld generates a core file.
.IP \(bu 4
2: only the slurmctld is shutdown (no core file).
.RE
.RS 2
.RE
.IP \(bu 2
RET: error code.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->\fR\f(BItakeover()\fR\fI;\fR
.IX Subsection "$rc = $slurm->takeover();"
.PP
Issue RPC to have Slurm backup controller take over the primary controller. REQUEST_CONTROL is sent by the backup to the primary controller to take control.
.IP \(bu 2
RET: error code.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->set_debug_level($debug_level)\fR
.IX Subsection "$rc = $slurm->set_debug_level($debug_level)"
.PP
Issue RPC to set slurm controller debug level.
.IP \(bu 2
IN \f(CW$debug_level:\fR requested debug level.
.IP \(bu 2
RET: 0 on success, \-1 on error with errno set.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->set_schedlog_level($schedlog_level);\fR
.IX Subsection "$rc = $slurm->set_schedlog_level($schedlog_level);"
.PP
Issue RPC to set slurm scheduler log level.
.IP \(bu 2
schedlog_level: requested scheduler log level.
.IP \(bu 2
RET: 0 on success, \-1 on error with errno set.
.SS "SLURM JOB SUSPEND FUNCTIONS"
.IX Subsection "SLURM JOB SUSPEND FUNCTIONS"
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->suspend($job_id);\fR
.IX Subsection "$rc = $slurm->suspend($job_id);"
.PP
Suspend execution of a job.
.IP \(bu 2
IN \f(CW$job_id:\fR job on which top perform operation.
.IP \(bu 2
RET: error code.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->resume($job_id);\fR
.IX Subsection "$rc = $slurm->resume($job_id);"
.PP
Resume execution of a previously suspended job.
.IP \(bu 2
IN \f(CW$job_id:\fR job on which to perform operation.
.IP \(bu 2
RET: error code.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->requeue($job_id);\fR
.IX Subsection "$rc = $slurm->requeue($job_id);"
.PP
Re-queue a batch job, if already running then terminate it first.
.IP \(bu 2
IN \f(CW$job_id:\fR job on which to perform operation.
.IP \(bu 2
RET: error code.
.SS "SLURM TRIGGER FUNCTIONS"
.IX Subsection "SLURM TRIGGER FUNCTIONS"
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->set_trigger($trigger_info);\fR
.IX Subsection "$rc = $slurm->set_trigger($trigger_info);"
.PP
Set an event trigger.
.IP \(bu 2
IN \f(CW$trigger_info:\fR hash reference of specification of trigger to create, with structure of \f(CW\*(C`trigger_info_t\*(C'\fR.
.IP \(bu 2
RET: error code.
.PP
\fR\f(CI$rc\fR\fI = \fR\f(CI$slurm\fR\fI\->clear_trigger($trigger_info);\fR
.IX Subsection "$rc = $slurm->clear_trigger($trigger_info);"
.PP
Clear an existing event trigger.
.IP \(bu 2
IN \f(CW$trigger_info:\fR hash reference of specification of trigger to remove, with structure of \f(CW\*(C`trigger_info_t\*(C'\fR.
.IP \(bu 2
RET: error code.
.PP
\fR\f(CI$resp\fR\fI = \fR\f(CI$slurm\fR\fI\->\fR\f(BIget_triggers()\fR\fI;\fR
.IX Subsection "$resp = $slurm->get_triggers();"
.PP
Get all event trigger information.
.IP \(bu 2
RET: hash reference with structure of \f(CW\*(C`trigger_info_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.SS "JOB/NODE STATE TESTING FUNCTIONS"
.IX Subsection "JOB/NODE STATE TESTING FUNCTIONS"
The following are functions to test job/node state, based on the macros defined in \fIsrc/common/slurm_protocol_defs.h\fR. The functions take a parameter of a hash reference of a job/node, and return a boolean value. For job, \f(CW$job\fR\->{job_state} is tested. For node, \f(CW$node\fR\->{node_state} is tested.
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_PENDING($job);\fR
.IX Subsection "$cond = IS_JOB_PENDING($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_RUNNING($job);\fR
.IX Subsection "$cond = IS_JOB_RUNNING($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_SUSPENDED($job);\fR
.IX Subsection "$cond = IS_JOB_SUSPENDED($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_COMPLETE($job);\fR
.IX Subsection "$cond = IS_JOB_COMPLETE($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_CANCELLED($job);\fR
.IX Subsection "$cond = IS_JOB_CANCELLED($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_FAILED($job);\fR
.IX Subsection "$cond = IS_JOB_FAILED($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_TIMEOUT($job);\fR
.IX Subsection "$cond = IS_JOB_TIMEOUT($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_NODE_FAILED($job);\fR
.IX Subsection "$cond = IS_JOB_NODE_FAILED($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_COMPLETING($job);\fR
.IX Subsection "$cond = IS_JOB_COMPLETING($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_CONFIGURING($job);\fR
.IX Subsection "$cond = IS_JOB_CONFIGURING($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_STARTED($job);\fR
.IX Subsection "$cond = IS_JOB_STARTED($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_FINISHED($job);\fR
.IX Subsection "$cond = IS_JOB_FINISHED($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_COMPLETED($job);\fR
.IX Subsection "$cond = IS_JOB_COMPLETED($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_JOB_RESIZING($job);\fR
.IX Subsection "$cond = IS_JOB_RESIZING($job);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_UNKNOWN($node);\fR
.IX Subsection "$cond = IS_NODE_UNKNOWN($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_DOWN($node);\fR
.IX Subsection "$cond = IS_NODE_DOWN($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_IDLE($node);\fR
.IX Subsection "$cond = IS_NODE_IDLE($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_ALLOCATED($node);\fR
.IX Subsection "$cond = IS_NODE_ALLOCATED($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_ERROR($node);\fR
.IX Subsection "$cond = IS_NODE_ERROR($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_MIXED($node);\fR
.IX Subsection "$cond = IS_NODE_MIXED($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_FUTURE($node);\fR
.IX Subsection "$cond = IS_NODE_FUTURE($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_DRAIN($node);\fR
.IX Subsection "$cond = IS_NODE_DRAIN($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_DRAINING($node);\fR
.IX Subsection "$cond = IS_NODE_DRAINING($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_DRAINED($node);\fR
.IX Subsection "$cond = IS_NODE_DRAINED($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_COMPLETING($node);\fR
.IX Subsection "$cond = IS_NODE_COMPLETING($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_NO_RESPOND($node);\fR
.IX Subsection "$cond = IS_NODE_NO_RESPOND($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_POWERED_DOWN($node);\fR
.IX Subsection "$cond = IS_NODE_POWERED_DOWN($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_POWER_UP($node);\fR
.IX Subsection "$cond = IS_NODE_POWER_UP($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_FAIL($node);\fR
.IX Subsection "$cond = IS_NODE_FAIL($node);"
.PP
\fR\f(CI$cond\fR\fI = IS_NODE_MAINT($node);\fR
.IX Subsection "$cond = IS_NODE_MAINT($node);"
.SH EXPORT
.IX Header "EXPORT"
The job/node state testing functions are exported by default.
.PP
If ':constant' if specified, all constants are exported.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Slurm::Constant, Slurm::Hostlist, Slurm::Bitstr
.PP
<slurm/slurm.h> for various hash reference structures.
.PP
Home page of Slurm: <http://slurm.schedmd.com>.
.SH AUTHOR
.IX Header "AUTHOR"
This library is created by Hongjia Cao, <hjcao(AT)nudt.edu.cn> and Danny Auble, <da(AT)llnl.gov>. It is distributed with Slurm.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.4 or,
at your option, any later version of Perl 5 you may have available.
